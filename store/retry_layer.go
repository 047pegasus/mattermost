// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make store-layers"
// DO NOT EDIT

package store

import (
	"context"
	"fmt"
	"strings"

	"github.com/mattermost/mattermost-server/v5/model"
)

type RetryLayer struct {
	Store
	AuditStore                AuditStore
	BotStore                  BotStore
	ChannelStore              ChannelStore
	ChannelMemberHistoryStore ChannelMemberHistoryStore
	ClusterDiscoveryStore     ClusterDiscoveryStore
	CommandStore              CommandStore
	CommandWebhookStore       CommandWebhookStore
	ComplianceStore           ComplianceStore
	EmojiStore                EmojiStore
	FileInfoStore             FileInfoStore
	GroupStore                GroupStore
	JobStore                  JobStore
	LicenseStore              LicenseStore
	LinkMetadataStore         LinkMetadataStore
	OAuthStore                OAuthStore
	PluginStore               PluginStore
	PostStore                 PostStore
	PreferenceStore           PreferenceStore
	ReactionStore             ReactionStore
	RoleStore                 RoleStore
	SchemeStore               SchemeStore
	SessionStore              SessionStore
	StatusStore               StatusStore
	SystemStore               SystemStore
	TeamStore                 TeamStore
	TermsOfServiceStore       TermsOfServiceStore
	TokenStore                TokenStore
	UserStore                 UserStore
	UserAccessTokenStore      UserAccessTokenStore
	UserTermsOfServiceStore   UserTermsOfServiceStore
	WebhookStore              WebhookStore
}

func (s *RetryLayer) Audit() AuditStore {
	return s.AuditStore
}

func (s *RetryLayer) Bot() BotStore {
	return s.BotStore
}

func (s *RetryLayer) Channel() ChannelStore {
	return s.ChannelStore
}

func (s *RetryLayer) ChannelMemberHistory() ChannelMemberHistoryStore {
	return s.ChannelMemberHistoryStore
}

func (s *RetryLayer) ClusterDiscovery() ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *RetryLayer) Command() CommandStore {
	return s.CommandStore
}

func (s *RetryLayer) CommandWebhook() CommandWebhookStore {
	return s.CommandWebhookStore
}

func (s *RetryLayer) Compliance() ComplianceStore {
	return s.ComplianceStore
}

func (s *RetryLayer) Emoji() EmojiStore {
	return s.EmojiStore
}

func (s *RetryLayer) FileInfo() FileInfoStore {
	return s.FileInfoStore
}

func (s *RetryLayer) Group() GroupStore {
	return s.GroupStore
}

func (s *RetryLayer) Job() JobStore {
	return s.JobStore
}

func (s *RetryLayer) License() LicenseStore {
	return s.LicenseStore
}

func (s *RetryLayer) LinkMetadata() LinkMetadataStore {
	return s.LinkMetadataStore
}

func (s *RetryLayer) OAuth() OAuthStore {
	return s.OAuthStore
}

func (s *RetryLayer) Plugin() PluginStore {
	return s.PluginStore
}

func (s *RetryLayer) Post() PostStore {
	return s.PostStore
}

func (s *RetryLayer) Preference() PreferenceStore {
	return s.PreferenceStore
}

func (s *RetryLayer) Reaction() ReactionStore {
	return s.ReactionStore
}

func (s *RetryLayer) Role() RoleStore {
	return s.RoleStore
}

func (s *RetryLayer) Scheme() SchemeStore {
	return s.SchemeStore
}

func (s *RetryLayer) Session() SessionStore {
	return s.SessionStore
}

func (s *RetryLayer) Status() StatusStore {
	return s.StatusStore
}

func (s *RetryLayer) System() SystemStore {
	return s.SystemStore
}

func (s *RetryLayer) Team() TeamStore {
	return s.TeamStore
}

func (s *RetryLayer) TermsOfService() TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *RetryLayer) Token() TokenStore {
	return s.TokenStore
}

func (s *RetryLayer) User() UserStore {
	return s.UserStore
}

func (s *RetryLayer) UserAccessToken() UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *RetryLayer) UserTermsOfService() UserTermsOfServiceStore {
	return s.UserTermsOfServiceStore
}

func (s *RetryLayer) Webhook() WebhookStore {
	return s.WebhookStore
}

type RetryLayerAuditStore struct {
	AuditStore
	Root *RetryLayer
}

type RetryLayerBotStore struct {
	BotStore
	Root *RetryLayer
}

type RetryLayerChannelStore struct {
	ChannelStore
	Root *RetryLayer
}

type RetryLayerChannelMemberHistoryStore struct {
	ChannelMemberHistoryStore
	Root *RetryLayer
}

type RetryLayerClusterDiscoveryStore struct {
	ClusterDiscoveryStore
	Root *RetryLayer
}

type RetryLayerCommandStore struct {
	CommandStore
	Root *RetryLayer
}

type RetryLayerCommandWebhookStore struct {
	CommandWebhookStore
	Root *RetryLayer
}

type RetryLayerComplianceStore struct {
	ComplianceStore
	Root *RetryLayer
}

type RetryLayerEmojiStore struct {
	EmojiStore
	Root *RetryLayer
}

type RetryLayerFileInfoStore struct {
	FileInfoStore
	Root *RetryLayer
}

type RetryLayerGroupStore struct {
	GroupStore
	Root *RetryLayer
}

type RetryLayerJobStore struct {
	JobStore
	Root *RetryLayer
}

type RetryLayerLicenseStore struct {
	LicenseStore
	Root *RetryLayer
}

type RetryLayerLinkMetadataStore struct {
	LinkMetadataStore
	Root *RetryLayer
}

type RetryLayerOAuthStore struct {
	OAuthStore
	Root *RetryLayer
}

type RetryLayerPluginStore struct {
	PluginStore
	Root *RetryLayer
}

type RetryLayerPostStore struct {
	PostStore
	Root *RetryLayer
}

type RetryLayerPreferenceStore struct {
	PreferenceStore
	Root *RetryLayer
}

type RetryLayerReactionStore struct {
	ReactionStore
	Root *RetryLayer
}

type RetryLayerRoleStore struct {
	RoleStore
	Root *RetryLayer
}

type RetryLayerSchemeStore struct {
	SchemeStore
	Root *RetryLayer
}

type RetryLayerSessionStore struct {
	SessionStore
	Root *RetryLayer
}

type RetryLayerStatusStore struct {
	StatusStore
	Root *RetryLayer
}

type RetryLayerSystemStore struct {
	SystemStore
	Root *RetryLayer
}

type RetryLayerTeamStore struct {
	TeamStore
	Root *RetryLayer
}

type RetryLayerTermsOfServiceStore struct {
	TermsOfServiceStore
	Root *RetryLayer
}

type RetryLayerTokenStore struct {
	TokenStore
	Root *RetryLayer
}

type RetryLayerUserStore struct {
	UserStore
	Root *RetryLayer
}

type RetryLayerUserAccessTokenStore struct {
	UserAccessTokenStore
	Root *RetryLayer
}

type RetryLayerUserTermsOfServiceStore struct {
	UserTermsOfServiceStore
	Root *RetryLayer
}

type RetryLayerWebhookStore struct {
	WebhookStore
	Root *RetryLayer
}

func (s *RetryLayerAuditStore) Get(user_id string, offset int, limit int) (model.Audits, *model.AppError) {

	resultVar0, resultVar1 := s.AuditStore.Get(user_id, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.AuditStore.Get(user_id, offset, limit)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerAuditStore) PermanentDeleteByUser(userId string) *model.AppError {

	resultVar0 := s.AuditStore.PermanentDeleteByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.AuditStore.PermanentDeleteByUser(userId)
		fmt.Println("RETRYING PermanentDeleteByUser")
	}

	return resultVar0

}

func (s *RetryLayerAuditStore) Save(audit *model.Audit) *model.AppError {

	resultVar0 := s.AuditStore.Save(audit)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.AuditStore.Save(audit)
		fmt.Println("RETRYING Save")
	}

	return resultVar0

}

func (s *RetryLayerBotStore) Get(userId string, includeDeleted bool) (*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.Get(userId, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.BotStore.Get(userId, includeDeleted)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerBotStore) GetAll(options *model.BotGetOptions) ([]*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.GetAll(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.BotStore.GetAll(options)
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerBotStore) PermanentDelete(userId string) error {

	resultVar0 := s.BotStore.PermanentDelete(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.BotStore.PermanentDelete(userId)
		fmt.Println("RETRYING PermanentDelete")
	}

	return resultVar0

}

func (s *RetryLayerBotStore) Save(bot *model.Bot) (*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.Save(bot)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.BotStore.Save(bot)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerBotStore) Update(bot *model.Bot) (*model.Bot, error) {

	resultVar0, resultVar1 := s.BotStore.Update(bot)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.BotStore.Update(bot)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AnalyticsDeletedTypeCount(teamId string, channelType string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AnalyticsDeletedTypeCount(teamId, channelType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.AnalyticsDeletedTypeCount(teamId, channelType)
		fmt.Println("RETRYING AnalyticsDeletedTypeCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AnalyticsTypeCount(teamId string, channelType string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AnalyticsTypeCount(teamId, channelType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.AnalyticsTypeCount(teamId, channelType)
		fmt.Println("RETRYING AnalyticsTypeCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AutocompleteInTeam(teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AutocompleteInTeam(teamId, term, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.AutocompleteInTeam(teamId, term, includeDeleted)
		fmt.Println("RETRYING AutocompleteInTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) AutocompleteInTeamForSearch(teamId string, userId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.AutocompleteInTeamForSearch(teamId, userId, term, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.AutocompleteInTeamForSearch(teamId, userId, term, includeDeleted)
		fmt.Println("RETRYING AutocompleteInTeamForSearch")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) ClearAllCustomRoleAssignments() *model.AppError {

	resultVar0 := s.ChannelStore.ClearAllCustomRoleAssignments()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.ClearAllCustomRoleAssignments()
		fmt.Println("RETRYING ClearAllCustomRoleAssignments")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) ClearCaches() {

	s.ChannelStore.ClearCaches()
	return

}

func (s *RetryLayerChannelStore) CountPostsAfter(channelId string, timestamp int64, userId string) (int, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.CountPostsAfter(channelId, timestamp, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.CountPostsAfter(channelId, timestamp, userId)
		fmt.Println("RETRYING CountPostsAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) CreateDirectChannel(userId *model.User, otherUserId *model.User) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.CreateDirectChannel(userId, otherUserId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.CreateDirectChannel(userId, otherUserId)
		fmt.Println("RETRYING CreateDirectChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) Delete(channelId string, time int64) error {

	resultVar0 := s.ChannelStore.Delete(channelId, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.Delete(channelId, time)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Get(id string, allowFromCache bool) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.Get(id, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.Get(id, allowFromCache)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAll(teamId string) ([]*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAll(teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetAll(teamId)
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelMembersForUser(userId string, allowFromCache bool, includeDeleted bool) (map[string]string, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelMembersForUser(userId, allowFromCache, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelMembersForUser(userId, allowFromCache, includeDeleted)
		fmt.Println("RETRYING GetAllChannelMembersForUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelMembersNotifyPropsForChannel(channelId string, allowFromCache bool) (map[string]model.StringMap, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelMembersNotifyPropsForChannel(channelId, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelMembersNotifyPropsForChannel(channelId, allowFromCache)
		fmt.Println("RETRYING GetAllChannelMembersNotifyPropsForChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannels(page int, perPage int, opts ChannelSearchOpts) (*model.ChannelListWithTeamData, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannels(page, perPage, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetAllChannels(page, perPage, opts)
		fmt.Println("RETRYING GetAllChannels")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelsCount(opts ChannelSearchOpts) (int64, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelsCount(opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelsCount(opts)
		fmt.Println("RETRYING GetAllChannelsCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllChannelsForExportAfter(limit int, afterId string) ([]*model.ChannelForExport, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllChannelsForExportAfter(limit, afterId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetAllChannelsForExportAfter(limit, afterId)
		fmt.Println("RETRYING GetAllChannelsForExportAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetAllDirectChannelsForExportAfter(limit int, afterId string) ([]*model.DirectChannelForExport, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetAllDirectChannelsForExportAfter(limit, afterId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetAllDirectChannelsForExportAfter(limit, afterId)
		fmt.Println("RETRYING GetAllDirectChannelsForExportAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetByName(team_id string, name string, allowFromCache bool) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetByName(team_id, name, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetByName(team_id, name, allowFromCache)
		fmt.Println("RETRYING GetByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetByNameIncludeDeleted(team_id string, name string, allowFromCache bool) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetByNameIncludeDeleted(team_id, name, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetByNameIncludeDeleted(team_id, name, allowFromCache)
		fmt.Println("RETRYING GetByNameIncludeDeleted")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetByNames(team_id string, names []string, allowFromCache bool) ([]*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetByNames(team_id, names, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetByNames(team_id, names, allowFromCache)
		fmt.Println("RETRYING GetByNames")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelCounts(teamId string, userId string) (*model.ChannelCounts, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelCounts(teamId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannelCounts(teamId, userId)
		fmt.Println("RETRYING GetChannelCounts")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelMembersForExport(userId string, teamId string) ([]*model.ChannelMemberForExport, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelMembersForExport(userId, teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannelMembersForExport(userId, teamId)
		fmt.Println("RETRYING GetChannelMembersForExport")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelMembersTimezones(channelId string) ([]model.StringMap, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelMembersTimezones(channelId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannelMembersTimezones(channelId)
		fmt.Println("RETRYING GetChannelMembersTimezones")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelUnread(channelId string, userId string) (*model.ChannelUnread, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelUnread(channelId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannelUnread(channelId, userId)
		fmt.Println("RETRYING GetChannelUnread")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannels(teamId string, userId string, includeDeleted bool) (*model.ChannelList, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannels(teamId, userId, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannels(teamId, userId, includeDeleted)
		fmt.Println("RETRYING GetChannels")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelsBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelsBatchForIndexing(startTime, endTime, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannelsBatchForIndexing(startTime, endTime, limit)
		fmt.Println("RETRYING GetChannelsBatchForIndexing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelsByIds(channelIds []string, includeDeleted bool) ([]*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelsByIds(channelIds, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannelsByIds(channelIds, includeDeleted)
		fmt.Println("RETRYING GetChannelsByIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetChannelsByScheme(schemeId string, offset int, limit int) (model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetChannelsByScheme(schemeId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetChannelsByScheme(schemeId, offset, limit)
		fmt.Println("RETRYING GetChannelsByScheme")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetDeleted(team_id string, offset int, limit int, userId string) (*model.ChannelList, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetDeleted(team_id, offset, limit, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetDeleted(team_id, offset, limit, userId)
		fmt.Println("RETRYING GetDeleted")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetDeletedByName(team_id string, name string) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetDeletedByName(team_id, name)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetDeletedByName(team_id, name)
		fmt.Println("RETRYING GetDeletedByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetForPost(postId string) (*model.Channel, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetForPost(postId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetForPost(postId)
		fmt.Println("RETRYING GetForPost")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetFromMaster(id string) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetFromMaster(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetFromMaster(id)
		fmt.Println("RETRYING GetFromMaster")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetGuestCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetGuestCount(channelId, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetGuestCount(channelId, allowFromCache)
		fmt.Println("RETRYING GetGuestCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMember(channelId string, userId string) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMember(channelId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMember(channelId, userId)
		fmt.Println("RETRYING GetMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMemberCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMemberCount(channelId, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMemberCount(channelId, allowFromCache)
		fmt.Println("RETRYING GetMemberCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMemberCountFromCache(channelId string) int64 {

	resultVar0 := s.ChannelStore.GetMemberCountFromCache(channelId)

	return resultVar0

}

func (s *RetryLayerChannelStore) GetMemberCountsByGroup(channelID string, includeTimezones bool) ([]*model.ChannelMemberCountByGroup, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMemberCountsByGroup(channelID, includeTimezones)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMemberCountsByGroup(channelID, includeTimezones)
		fmt.Println("RETRYING GetMemberCountsByGroup")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMemberForPost(postId string, userId string) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMemberForPost(postId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMemberForPost(postId, userId)
		fmt.Println("RETRYING GetMemberForPost")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembers(channelId string, offset int, limit int) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembers(channelId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMembers(channelId, offset, limit)
		fmt.Println("RETRYING GetMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembersByIds(channelId string, userIds []string) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembersByIds(channelId, userIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMembersByIds(channelId, userIds)
		fmt.Println("RETRYING GetMembersByIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembersForUser(teamId string, userId string) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembersForUser(teamId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMembersForUser(teamId, userId)
		fmt.Println("RETRYING GetMembersForUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMembersForUserWithPagination(teamId string, userId string, page int, perPage int) (*model.ChannelMembers, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetMembersForUserWithPagination(teamId, userId, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMembersForUserWithPagination(teamId, userId, page, perPage)
		fmt.Println("RETRYING GetMembersForUserWithPagination")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetMoreChannels(teamId string, userId string, offset int, limit int) (*model.ChannelList, error) {

	resultVar0, resultVar1 := s.ChannelStore.GetMoreChannels(teamId, userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetMoreChannels(teamId, userId, offset, limit)
		fmt.Println("RETRYING GetMoreChannels")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPinnedPostCount(channelId string, allowFromCache bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPinnedPostCount(channelId, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetPinnedPostCount(channelId, allowFromCache)
		fmt.Println("RETRYING GetPinnedPostCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPinnedPosts(channelId string) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPinnedPosts(channelId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetPinnedPosts(channelId)
		fmt.Println("RETRYING GetPinnedPosts")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPublicChannelsByIdsForTeam(teamId string, channelIds []string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPublicChannelsByIdsForTeam(teamId, channelIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetPublicChannelsByIdsForTeam(teamId, channelIds)
		fmt.Println("RETRYING GetPublicChannelsByIdsForTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetPublicChannelsForTeam(teamId string, offset int, limit int) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetPublicChannelsForTeam(teamId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetPublicChannelsForTeam(teamId, offset, limit)
		fmt.Println("RETRYING GetPublicChannelsForTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GetTeamChannels(teamId string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GetTeamChannels(teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GetTeamChannels(teamId)
		fmt.Println("RETRYING GetTeamChannels")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) GroupSyncedChannelCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.GroupSyncedChannelCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.GroupSyncedChannelCount()
		fmt.Println("RETRYING GroupSyncedChannelCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) IncrementMentionCount(channelId string, userId string) *model.AppError {

	resultVar0 := s.ChannelStore.IncrementMentionCount(channelId, userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.IncrementMentionCount(channelId, userId)
		fmt.Println("RETRYING IncrementMentionCount")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) InvalidateAllChannelMembersForUser(userId string) {

	s.ChannelStore.InvalidateAllChannelMembersForUser(userId)
	return

}

func (s *RetryLayerChannelStore) InvalidateCacheForChannelMembersNotifyProps(channelId string) {

	s.ChannelStore.InvalidateCacheForChannelMembersNotifyProps(channelId)
	return

}

func (s *RetryLayerChannelStore) InvalidateChannel(id string) {

	s.ChannelStore.InvalidateChannel(id)
	return

}

func (s *RetryLayerChannelStore) InvalidateChannelByName(teamId string, name string) {

	s.ChannelStore.InvalidateChannelByName(teamId, name)
	return

}

func (s *RetryLayerChannelStore) InvalidateGuestCount(channelId string) {

	s.ChannelStore.InvalidateGuestCount(channelId)
	return

}

func (s *RetryLayerChannelStore) InvalidateMemberCount(channelId string) {

	s.ChannelStore.InvalidateMemberCount(channelId)
	return

}

func (s *RetryLayerChannelStore) InvalidatePinnedPostCount(channelId string) {

	s.ChannelStore.InvalidatePinnedPostCount(channelId)
	return

}

func (s *RetryLayerChannelStore) IsUserInChannelUseCache(userId string, channelId string) bool {

	resultVar0 := s.ChannelStore.IsUserInChannelUseCache(userId, channelId)

	return resultVar0

}

func (s *RetryLayerChannelStore) MigrateChannelMembers(fromChannelId string, fromUserId string) (map[string]string, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.MigrateChannelMembers(fromChannelId, fromUserId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.MigrateChannelMembers(fromChannelId, fromUserId)
		fmt.Println("RETRYING MigrateChannelMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) MigratePublicChannels() error {

	resultVar0 := s.ChannelStore.MigratePublicChannels()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.MigratePublicChannels()
		fmt.Println("RETRYING MigratePublicChannels")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDelete(channelId string) error {

	resultVar0 := s.ChannelStore.PermanentDelete(channelId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.PermanentDelete(channelId)
		fmt.Println("RETRYING PermanentDelete")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDeleteByTeam(teamId string) error {

	resultVar0 := s.ChannelStore.PermanentDeleteByTeam(teamId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.PermanentDeleteByTeam(teamId)
		fmt.Println("RETRYING PermanentDeleteByTeam")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDeleteMembersByChannel(channelId string) *model.AppError {

	resultVar0 := s.ChannelStore.PermanentDeleteMembersByChannel(channelId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.PermanentDeleteMembersByChannel(channelId)
		fmt.Println("RETRYING PermanentDeleteMembersByChannel")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) PermanentDeleteMembersByUser(userId string) *model.AppError {

	resultVar0 := s.ChannelStore.PermanentDeleteMembersByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.PermanentDeleteMembersByUser(userId)
		fmt.Println("RETRYING PermanentDeleteMembersByUser")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) RemoveAllDeactivatedMembers(channelId string) *model.AppError {

	resultVar0 := s.ChannelStore.RemoveAllDeactivatedMembers(channelId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.RemoveAllDeactivatedMembers(channelId)
		fmt.Println("RETRYING RemoveAllDeactivatedMembers")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) RemoveMember(channelId string, userId string) *model.AppError {

	resultVar0 := s.ChannelStore.RemoveMember(channelId, userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.RemoveMember(channelId, userId)
		fmt.Println("RETRYING RemoveMember")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) RemoveMembers(channelId string, userIds []string) *model.AppError {

	resultVar0 := s.ChannelStore.RemoveMembers(channelId, userIds)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.RemoveMembers(channelId, userIds)
		fmt.Println("RETRYING RemoveMembers")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) ResetAllChannelSchemes() *model.AppError {

	resultVar0 := s.ChannelStore.ResetAllChannelSchemes()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.ResetAllChannelSchemes()
		fmt.Println("RETRYING ResetAllChannelSchemes")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Restore(channelId string, time int64) error {

	resultVar0 := s.ChannelStore.Restore(channelId, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.Restore(channelId, time)
		fmt.Println("RETRYING Restore")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Save(channel *model.Channel, maxChannelsPerTeam int64) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.Save(channel, maxChannelsPerTeam)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.Save(channel, maxChannelsPerTeam)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SaveDirectChannel(channel *model.Channel, member1 *model.ChannelMember, member2 *model.ChannelMember) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.SaveDirectChannel(channel, member1, member2)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SaveDirectChannel(channel, member1, member2)
		fmt.Println("RETRYING SaveDirectChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SaveMember(member *model.ChannelMember) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SaveMember(member)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SaveMember(member)
		fmt.Println("RETRYING SaveMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SaveMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SaveMultipleMembers(members)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SaveMultipleMembers(members)
		fmt.Println("RETRYING SaveMultipleMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchAllChannels(term string, opts ChannelSearchOpts) (*model.ChannelListWithTeamData, int64, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.ChannelStore.SearchAllChannels(term, opts)

	for {
		if resultVar2 == nil || !strings.Contains(resultVar2.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1, resultVar2 = s.ChannelStore.SearchAllChannels(term, opts)
		fmt.Println("RETRYING SearchAllChannels")
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerChannelStore) SearchArchivedInTeam(teamId string, term string, userId string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchArchivedInTeam(teamId, term, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SearchArchivedInTeam(teamId, term, userId)
		fmt.Println("RETRYING SearchArchivedInTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchForUserInTeam(userId string, teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchForUserInTeam(userId, teamId, term, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SearchForUserInTeam(userId, teamId, term, includeDeleted)
		fmt.Println("RETRYING SearchForUserInTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchGroupChannels(userId string, term string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchGroupChannels(userId, term)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SearchGroupChannels(userId, term)
		fmt.Println("RETRYING SearchGroupChannels")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchInTeam(teamId string, term string, includeDeleted bool) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchInTeam(teamId, term, includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SearchInTeam(teamId, term, includeDeleted)
		fmt.Println("RETRYING SearchInTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SearchMore(userId string, teamId string, term string) (*model.ChannelList, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.SearchMore(userId, teamId, term)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.SearchMore(userId, teamId, term)
		fmt.Println("RETRYING SearchMore")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) SetDeleteAt(channelId string, deleteAt int64, updateAt int64) error {

	resultVar0 := s.ChannelStore.SetDeleteAt(channelId, deleteAt, updateAt)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.SetDeleteAt(channelId, deleteAt, updateAt)
		fmt.Println("RETRYING SetDeleteAt")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) Update(channel *model.Channel) (*model.Channel, error) {

	resultVar0, resultVar1 := s.ChannelStore.Update(channel)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.Update(channel)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateLastViewedAt(channelIds []string, userId string) (map[string]int64, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateLastViewedAt(channelIds, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.UpdateLastViewedAt(channelIds, userId)
		fmt.Println("RETRYING UpdateLastViewedAt")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateLastViewedAtPost(unreadPost *model.Post, userID string, mentionCount int) (*model.ChannelUnreadAt, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateLastViewedAtPost(unreadPost, userID, mentionCount)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.UpdateLastViewedAtPost(unreadPost, userID, mentionCount)
		fmt.Println("RETRYING UpdateLastViewedAtPost")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateMember(member *model.ChannelMember) (*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateMember(member)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.UpdateMember(member)
		fmt.Println("RETRYING UpdateMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UpdateMembersRole(channelID string, userIDs []string) *model.AppError {

	resultVar0 := s.ChannelStore.UpdateMembersRole(channelID, userIDs)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelStore.UpdateMembersRole(channelID, userIDs)
		fmt.Println("RETRYING UpdateMembersRole")
	}

	return resultVar0

}

func (s *RetryLayerChannelStore) UpdateMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UpdateMultipleMembers(members)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.UpdateMultipleMembers(members)
		fmt.Println("RETRYING UpdateMultipleMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelStore) UserBelongsToChannels(userId string, channelIds []string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.ChannelStore.UserBelongsToChannels(userId, channelIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelStore.UserBelongsToChannels(userId, channelIds)
		fmt.Println("RETRYING UserBelongsToChannels")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelMemberHistoryStore) GetUsersInChannelDuring(startTime int64, endTime int64, channelId string) ([]*model.ChannelMemberHistoryResult, error) {

	resultVar0, resultVar1 := s.ChannelMemberHistoryStore.GetUsersInChannelDuring(startTime, endTime, channelId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelMemberHistoryStore.GetUsersInChannelDuring(startTime, endTime, channelId)
		fmt.Println("RETRYING GetUsersInChannelDuring")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerChannelMemberHistoryStore) LogJoinEvent(userId string, channelId string, joinTime int64) error {

	resultVar0 := s.ChannelMemberHistoryStore.LogJoinEvent(userId, channelId, joinTime)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelMemberHistoryStore.LogJoinEvent(userId, channelId, joinTime)
		fmt.Println("RETRYING LogJoinEvent")
	}

	return resultVar0

}

func (s *RetryLayerChannelMemberHistoryStore) LogLeaveEvent(userId string, channelId string, leaveTime int64) error {

	resultVar0 := s.ChannelMemberHistoryStore.LogLeaveEvent(userId, channelId, leaveTime)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ChannelMemberHistoryStore.LogLeaveEvent(userId, channelId, leaveTime)
		fmt.Println("RETRYING LogLeaveEvent")
	}

	return resultVar0

}

func (s *RetryLayerChannelMemberHistoryStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {

	resultVar0, resultVar1 := s.ChannelMemberHistoryStore.PermanentDeleteBatch(endTime, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ChannelMemberHistoryStore.PermanentDeleteBatch(endTime, limit)
		fmt.Println("RETRYING PermanentDeleteBatch")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) Cleanup() *model.AppError {

	resultVar0 := s.ClusterDiscoveryStore.Cleanup()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ClusterDiscoveryStore.Cleanup()
		fmt.Println("RETRYING Cleanup")
	}

	return resultVar0

}

func (s *RetryLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.Delete(discovery)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ClusterDiscoveryStore.Delete(discovery)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.Exists(discovery)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ClusterDiscoveryStore.Exists(discovery)
		fmt.Println("RETRYING Exists")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, *model.AppError) {

	resultVar0, resultVar1 := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) *model.AppError {

	resultVar0 := s.ClusterDiscoveryStore.Save(discovery)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ClusterDiscoveryStore.Save(discovery)
		fmt.Println("RETRYING Save")
	}

	return resultVar0

}

func (s *RetryLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) *model.AppError {

	resultVar0 := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ClusterDiscoveryStore.SetLastPingAt(discovery)
		fmt.Println("RETRYING SetLastPingAt")
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) AnalyticsCommandCount(teamId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.AnalyticsCommandCount(teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandStore.AnalyticsCommandCount(teamId)
		fmt.Println("RETRYING AnalyticsCommandCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) Delete(commandId string, time int64) *model.AppError {

	resultVar0 := s.CommandStore.Delete(commandId, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.CommandStore.Delete(commandId, time)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) Get(id string) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) GetByTeam(teamId string) ([]*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.GetByTeam(teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandStore.GetByTeam(teamId)
		fmt.Println("RETRYING GetByTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) GetByTrigger(teamId string, trigger string) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.GetByTrigger(teamId, trigger)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandStore.GetByTrigger(teamId, trigger)
		fmt.Println("RETRYING GetByTrigger")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) PermanentDeleteByTeam(teamId string) *model.AppError {

	resultVar0 := s.CommandStore.PermanentDeleteByTeam(teamId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.CommandStore.PermanentDeleteByTeam(teamId)
		fmt.Println("RETRYING PermanentDeleteByTeam")
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) PermanentDeleteByUser(userId string) *model.AppError {

	resultVar0 := s.CommandStore.PermanentDeleteByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.CommandStore.PermanentDeleteByUser(userId)
		fmt.Println("RETRYING PermanentDeleteByUser")
	}

	return resultVar0

}

func (s *RetryLayerCommandStore) Save(webhook *model.Command) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.Save(webhook)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandStore.Save(webhook)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandStore) Update(hook *model.Command) (*model.Command, *model.AppError) {

	resultVar0, resultVar1 := s.CommandStore.Update(hook)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandStore.Update(hook)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandWebhookStore) Cleanup() {

	s.CommandWebhookStore.Cleanup()
	return

}

func (s *RetryLayerCommandWebhookStore) Get(id string) (*model.CommandWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.CommandWebhookStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandWebhookStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandWebhookStore) Save(webhook *model.CommandWebhook) (*model.CommandWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.CommandWebhookStore.Save(webhook)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.CommandWebhookStore.Save(webhook)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerCommandWebhookStore) TryUse(id string, limit int) *model.AppError {

	resultVar0 := s.CommandWebhookStore.TryUse(id, limit)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.CommandWebhookStore.TryUse(id, limit)
		fmt.Println("RETRYING TryUse")
	}

	return resultVar0

}

func (s *RetryLayerComplianceStore) ComplianceExport(compliance *model.Compliance) ([]*model.CompliancePost, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.ComplianceExport(compliance)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ComplianceStore.ComplianceExport(compliance)
		fmt.Println("RETRYING ComplianceExport")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) Get(id string) (*model.Compliance, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ComplianceStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.GetAll(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ComplianceStore.GetAll(offset, limit)
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) MessageExport(after int64, limit int) ([]*model.MessageExport, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.MessageExport(after, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ComplianceStore.MessageExport(after, limit)
		fmt.Println("RETRYING MessageExport")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) Save(compliance *model.Compliance) (*model.Compliance, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.Save(compliance)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ComplianceStore.Save(compliance)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerComplianceStore) Update(compliance *model.Compliance) (*model.Compliance, *model.AppError) {

	resultVar0, resultVar1 := s.ComplianceStore.Update(compliance)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ComplianceStore.Update(compliance)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) Delete(emoji *model.Emoji, time int64) error {

	resultVar0 := s.EmojiStore.Delete(emoji, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.EmojiStore.Delete(emoji, time)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerEmojiStore) Get(id string, allowFromCache bool) (*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.Get(id, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.EmojiStore.Get(id, allowFromCache)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) GetByName(name string, allowFromCache bool) (*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.GetByName(name, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.EmojiStore.GetByName(name, allowFromCache)
		fmt.Println("RETRYING GetByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) GetList(offset int, limit int, sort string) ([]*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.GetList(offset, limit, sort)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.EmojiStore.GetList(offset, limit, sort)
		fmt.Println("RETRYING GetList")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) GetMultipleByName(names []string) ([]*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.GetMultipleByName(names)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.EmojiStore.GetMultipleByName(names)
		fmt.Println("RETRYING GetMultipleByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) Save(emoji *model.Emoji) (*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.Save(emoji)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.EmojiStore.Save(emoji)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerEmojiStore) Search(name string, prefixOnly bool, limit int) ([]*model.Emoji, error) {

	resultVar0, resultVar1 := s.EmojiStore.Search(name, prefixOnly, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.EmojiStore.Search(name, prefixOnly, limit)
		fmt.Println("RETRYING Search")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) AttachToPost(fileId string, postId string, creatorId string) *model.AppError {

	resultVar0 := s.FileInfoStore.AttachToPost(fileId, postId, creatorId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.FileInfoStore.AttachToPost(fileId, postId, creatorId)
		fmt.Println("RETRYING AttachToPost")
	}

	return resultVar0

}

func (s *RetryLayerFileInfoStore) ClearCaches() {

	s.FileInfoStore.ClearCaches()
	return

}

func (s *RetryLayerFileInfoStore) DeleteForPost(postId string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.DeleteForPost(postId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.DeleteForPost(postId)
		fmt.Println("RETRYING DeleteForPost")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) Get(id string) (*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetByPath(path)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.GetByPath(path)
		fmt.Println("RETRYING GetByPath")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetForPost(postId string, readFromMaster bool, includeDeleted bool, allowFromCache bool) ([]*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetForPost(postId, readFromMaster, includeDeleted, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.GetForPost(postId, readFromMaster, includeDeleted, allowFromCache)
		fmt.Println("RETRYING GetForPost")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetForUser(userId string) ([]*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetForUser(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.GetForUser(userId)
		fmt.Println("RETRYING GetForUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.GetWithOptions(page, perPage, opt)
		fmt.Println("RETRYING GetWithOptions")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) InvalidateFileInfosForPostCache(postId string, deleted bool) {

	s.FileInfoStore.InvalidateFileInfosForPostCache(postId, deleted)
	return

}

func (s *RetryLayerFileInfoStore) PermanentDelete(fileId string) *model.AppError {

	resultVar0 := s.FileInfoStore.PermanentDelete(fileId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.FileInfoStore.PermanentDelete(fileId)
		fmt.Println("RETRYING PermanentDelete")
	}

	return resultVar0

}

func (s *RetryLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.PermanentDeleteBatch(endTime, limit)
		fmt.Println("RETRYING PermanentDeleteBatch")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) PermanentDeleteByUser(userId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.PermanentDeleteByUser(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.PermanentDeleteByUser(userId)
		fmt.Println("RETRYING PermanentDeleteByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerFileInfoStore) Save(info *model.FileInfo) (*model.FileInfo, *model.AppError) {

	resultVar0, resultVar1 := s.FileInfoStore.Save(info)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.FileInfoStore.Save(info)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) AdminRoleGroupsForSyncableMember(userID string, syncableID string, syncableType model.GroupSyncableType) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.AdminRoleGroupsForSyncableMember(userID, syncableID, syncableType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.AdminRoleGroupsForSyncableMember(userID, syncableID, syncableType)
		fmt.Println("RETRYING AdminRoleGroupsForSyncableMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) ChannelMembersMinusGroupMembers(channelID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.ChannelMembersMinusGroupMembers(channelID, groupIDs, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.ChannelMembersMinusGroupMembers(channelID, groupIDs, page, perPage)
		fmt.Println("RETRYING ChannelMembersMinusGroupMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) ChannelMembersToAdd(since int64, channelID *string) ([]*model.UserChannelIDPair, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.ChannelMembersToAdd(since, channelID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.ChannelMembersToAdd(since, channelID)
		fmt.Println("RETRYING ChannelMembersToAdd")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) ChannelMembersToRemove(channelID *string) ([]*model.ChannelMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.ChannelMembersToRemove(channelID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.ChannelMembersToRemove(channelID)
		fmt.Println("RETRYING ChannelMembersToRemove")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountChannelMembersMinusGroupMembers(channelID string, groupIDs []string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountChannelMembersMinusGroupMembers(channelID, groupIDs)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.CountChannelMembersMinusGroupMembers(channelID, groupIDs)
		fmt.Println("RETRYING CountChannelMembersMinusGroupMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountGroupsByChannel(channelId string, opts model.GroupSearchOpts) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountGroupsByChannel(channelId, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.CountGroupsByChannel(channelId, opts)
		fmt.Println("RETRYING CountGroupsByChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountGroupsByTeam(teamId string, opts model.GroupSearchOpts) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountGroupsByTeam(teamId, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.CountGroupsByTeam(teamId, opts)
		fmt.Println("RETRYING CountGroupsByTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CountTeamMembersMinusGroupMembers(teamID string, groupIDs []string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CountTeamMembersMinusGroupMembers(teamID, groupIDs)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.CountTeamMembersMinusGroupMembers(teamID, groupIDs)
		fmt.Println("RETRYING CountTeamMembersMinusGroupMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Create(group *model.Group) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Create(group)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.Create(group)
		fmt.Println("RETRYING Create")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) CreateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.CreateGroupSyncable(groupSyncable)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.CreateGroupSyncable(groupSyncable)
		fmt.Println("RETRYING CreateGroupSyncable")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Delete(groupID string) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Delete(groupID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.Delete(groupID)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) DeleteGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.DeleteGroupSyncable(groupID, syncableID, syncableType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.DeleteGroupSyncable(groupID, syncableID, syncableType)
		fmt.Println("RETRYING DeleteGroupSyncable")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) DeleteMember(groupID string, userID string) (*model.GroupMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.DeleteMember(groupID, userID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.DeleteMember(groupID, userID)
		fmt.Println("RETRYING DeleteMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) DistinctGroupMemberCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.DistinctGroupMemberCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.DistinctGroupMemberCount()
		fmt.Println("RETRYING DistinctGroupMemberCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Get(groupID string) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Get(groupID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.Get(groupID)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetAllBySource(groupSource model.GroupSource) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetAllBySource(groupSource)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetAllBySource(groupSource)
		fmt.Println("RETRYING GetAllBySource")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetAllGroupSyncablesByGroupId(groupID string, syncableType model.GroupSyncableType) ([]*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetAllGroupSyncablesByGroupId(groupID, syncableType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetAllGroupSyncablesByGroupId(groupID, syncableType)
		fmt.Println("RETRYING GetAllGroupSyncablesByGroupId")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByIDs(groupIDs []string) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByIDs(groupIDs)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetByIDs(groupIDs)
		fmt.Println("RETRYING GetByIDs")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByName(name string, opts model.GroupSearchOpts) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByName(name, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetByName(name, opts)
		fmt.Println("RETRYING GetByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByRemoteID(remoteID string, groupSource model.GroupSource) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByRemoteID(remoteID, groupSource)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetByRemoteID(remoteID, groupSource)
		fmt.Println("RETRYING GetByRemoteID")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetByUser(userId string) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetByUser(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetByUser(userId)
		fmt.Println("RETRYING GetByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupSyncable(groupID, syncableID, syncableType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetGroupSyncable(groupID, syncableID, syncableType)
		fmt.Println("RETRYING GetGroupSyncable")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroups(page int, perPage int, opts model.GroupSearchOpts) ([]*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroups(page, perPage, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetGroups(page, perPage, opts)
		fmt.Println("RETRYING GetGroups")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupsAssociatedToChannelsByTeam(teamId string, opts model.GroupSearchOpts) (map[string][]*model.GroupWithSchemeAdmin, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupsAssociatedToChannelsByTeam(teamId, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetGroupsAssociatedToChannelsByTeam(teamId, opts)
		fmt.Println("RETRYING GetGroupsAssociatedToChannelsByTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupsByChannel(channelId string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupsByChannel(channelId, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetGroupsByChannel(channelId, opts)
		fmt.Println("RETRYING GetGroupsByChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetGroupsByTeam(teamId string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetGroupsByTeam(teamId, opts)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetGroupsByTeam(teamId, opts)
		fmt.Println("RETRYING GetGroupsByTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberCount(groupID string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberCount(groupID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetMemberCount(groupID)
		fmt.Println("RETRYING GetMemberCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsers(groupID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsers(groupID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetMemberUsers(groupID)
		fmt.Println("RETRYING GetMemberUsers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsersInTeam(groupID string, teamID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsersInTeam(groupID, teamID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetMemberUsersInTeam(groupID, teamID)
		fmt.Println("RETRYING GetMemberUsersInTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsersNotInChannel(groupID string, channelID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsersNotInChannel(groupID, channelID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetMemberUsersNotInChannel(groupID, channelID)
		fmt.Println("RETRYING GetMemberUsersNotInChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GetMemberUsersPage(groupID string, page int, perPage int) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GetMemberUsersPage(groupID, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GetMemberUsersPage(groupID, page, perPage)
		fmt.Println("RETRYING GetMemberUsersPage")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupChannelCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupChannelCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GroupChannelCount()
		fmt.Println("RETRYING GroupChannelCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GroupCount()
		fmt.Println("RETRYING GroupCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupCountWithAllowReference() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupCountWithAllowReference()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GroupCountWithAllowReference()
		fmt.Println("RETRYING GroupCountWithAllowReference")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupMemberCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupMemberCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GroupMemberCount()
		fmt.Println("RETRYING GroupMemberCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) GroupTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.GroupTeamCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.GroupTeamCount()
		fmt.Println("RETRYING GroupTeamCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) PermanentDeleteMembersByUser(userId string) *model.AppError {

	resultVar0 := s.GroupStore.PermanentDeleteMembersByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.GroupStore.PermanentDeleteMembersByUser(userId)
		fmt.Println("RETRYING PermanentDeleteMembersByUser")
	}

	return resultVar0

}

func (s *RetryLayerGroupStore) PermittedSyncableAdmins(syncableID string, syncableType model.GroupSyncableType) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.PermittedSyncableAdmins(syncableID, syncableType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.PermittedSyncableAdmins(syncableID, syncableType)
		fmt.Println("RETRYING PermittedSyncableAdmins")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) TeamMembersMinusGroupMembers(teamID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.TeamMembersMinusGroupMembers(teamID, groupIDs, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.TeamMembersMinusGroupMembers(teamID, groupIDs, page, perPage)
		fmt.Println("RETRYING TeamMembersMinusGroupMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) TeamMembersToAdd(since int64, teamID *string) ([]*model.UserTeamIDPair, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.TeamMembersToAdd(since, teamID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.TeamMembersToAdd(since, teamID)
		fmt.Println("RETRYING TeamMembersToAdd")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) TeamMembersToRemove(teamID *string) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.TeamMembersToRemove(teamID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.TeamMembersToRemove(teamID)
		fmt.Println("RETRYING TeamMembersToRemove")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) Update(group *model.Group) (*model.Group, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.Update(group)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.Update(group)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) UpdateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.UpdateGroupSyncable(groupSyncable)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.UpdateGroupSyncable(groupSyncable)
		fmt.Println("RETRYING UpdateGroupSyncable")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerGroupStore) UpsertMember(groupID string, userID string) (*model.GroupMember, *model.AppError) {

	resultVar0, resultVar1 := s.GroupStore.UpsertMember(groupID, userID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.GroupStore.UpsertMember(groupID, userID)
		fmt.Println("RETRYING UpsertMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) Delete(id string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.Delete(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.Delete(id)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) Get(id string) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllByStatus(status string) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllByStatus(status)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.GetAllByStatus(status)
		fmt.Println("RETRYING GetAllByStatus")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllByType(jobType string) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllByType(jobType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.GetAllByType(jobType)
		fmt.Println("RETRYING GetAllByType")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllByTypePage(jobType, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.GetAllByTypePage(jobType, offset, limit)
		fmt.Println("RETRYING GetAllByTypePage")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetAllPage(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.GetAllPage(offset, limit)
		fmt.Println("RETRYING GetAllPage")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetCountByStatusAndType(status, jobType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.GetCountByStatusAndType(status, jobType)
		fmt.Println("RETRYING GetCountByStatusAndType")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.GetNewestJobByStatusAndType(status, jobType)
		fmt.Println("RETRYING GetNewestJobByStatusAndType")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) Save(job *model.Job) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.Save(job)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.Save(job)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.UpdateOptimistically(job, currentStatus)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.UpdateOptimistically(job, currentStatus)
		fmt.Println("RETRYING UpdateOptimistically")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) UpdateStatus(id string, status string) (*model.Job, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.UpdateStatus(id, status)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.UpdateStatus(id, status)
		fmt.Println("RETRYING UpdateStatus")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)
		fmt.Println("RETRYING UpdateStatusOptimistically")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLicenseStore) Get(id string) (*model.LicenseRecord, *model.AppError) {

	resultVar0, resultVar1 := s.LicenseStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.LicenseStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLicenseStore) Save(license *model.LicenseRecord) (*model.LicenseRecord, *model.AppError) {

	resultVar0, resultVar1 := s.LicenseStore.Save(license)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.LicenseStore.Save(license)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLinkMetadataStore) Get(url string, timestamp int64) (*model.LinkMetadata, error) {

	resultVar0, resultVar1 := s.LinkMetadataStore.Get(url, timestamp)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.LinkMetadataStore.Get(url, timestamp)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerLinkMetadataStore) Save(linkMetadata *model.LinkMetadata) (*model.LinkMetadata, error) {

	resultVar0, resultVar1 := s.LinkMetadataStore.Save(linkMetadata)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.LinkMetadataStore.Save(linkMetadata)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) DeleteApp(id string) *model.AppError {

	resultVar0 := s.OAuthStore.DeleteApp(id)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.OAuthStore.DeleteApp(id)
		fmt.Println("RETRYING DeleteApp")
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) GetAccessData(token string) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAccessData(token)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetAccessData(token)
		fmt.Println("RETRYING GetAccessData")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAccessDataByRefreshToken(token string) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAccessDataByRefreshToken(token)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetAccessDataByRefreshToken(token)
		fmt.Println("RETRYING GetAccessDataByRefreshToken")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAccessDataByUserForApp(userId string, clientId string) ([]*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAccessDataByUserForApp(userId, clientId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetAccessDataByUserForApp(userId, clientId)
		fmt.Println("RETRYING GetAccessDataByUserForApp")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetApp(id string) (*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetApp(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetApp(id)
		fmt.Println("RETRYING GetApp")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAppByUser(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAppByUser(userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetAppByUser(userId, offset, limit)
		fmt.Println("RETRYING GetAppByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetApps(offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetApps(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetApps(offset, limit)
		fmt.Println("RETRYING GetApps")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAuthData(code string) (*model.AuthData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAuthData(code)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetAuthData(code)
		fmt.Println("RETRYING GetAuthData")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetAuthorizedApps(userId string, offset int, limit int) ([]*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetAuthorizedApps(userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetAuthorizedApps(userId, offset, limit)
		fmt.Println("RETRYING GetAuthorizedApps")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) GetPreviousAccessData(userId string, clientId string) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.GetPreviousAccessData(userId, clientId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.GetPreviousAccessData(userId, clientId)
		fmt.Println("RETRYING GetPreviousAccessData")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) PermanentDeleteAuthDataByUser(userId string) *model.AppError {

	resultVar0 := s.OAuthStore.PermanentDeleteAuthDataByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.OAuthStore.PermanentDeleteAuthDataByUser(userId)
		fmt.Println("RETRYING PermanentDeleteAuthDataByUser")
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) RemoveAccessData(token string) *model.AppError {

	resultVar0 := s.OAuthStore.RemoveAccessData(token)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.OAuthStore.RemoveAccessData(token)
		fmt.Println("RETRYING RemoveAccessData")
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) RemoveAllAccessData() *model.AppError {

	resultVar0 := s.OAuthStore.RemoveAllAccessData()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.OAuthStore.RemoveAllAccessData()
		fmt.Println("RETRYING RemoveAllAccessData")
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) RemoveAuthData(code string) *model.AppError {

	resultVar0 := s.OAuthStore.RemoveAuthData(code)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.OAuthStore.RemoveAuthData(code)
		fmt.Println("RETRYING RemoveAuthData")
	}

	return resultVar0

}

func (s *RetryLayerOAuthStore) SaveAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.SaveAccessData(accessData)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.SaveAccessData(accessData)
		fmt.Println("RETRYING SaveAccessData")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) SaveApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.SaveApp(app)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.SaveApp(app)
		fmt.Println("RETRYING SaveApp")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) SaveAuthData(authData *model.AuthData) (*model.AuthData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.SaveAuthData(authData)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.SaveAuthData(authData)
		fmt.Println("RETRYING SaveAuthData")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) UpdateAccessData(accessData *model.AccessData) (*model.AccessData, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.UpdateAccessData(accessData)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.UpdateAccessData(accessData)
		fmt.Println("RETRYING UpdateAccessData")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerOAuthStore) UpdateApp(app *model.OAuthApp) (*model.OAuthApp, *model.AppError) {

	resultVar0, resultVar1 := s.OAuthStore.UpdateApp(app)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.OAuthStore.UpdateApp(app)
		fmt.Println("RETRYING UpdateApp")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PluginStore.CompareAndDelete(keyVal, oldValue)
		fmt.Println("RETRYING CompareAndDelete")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.CompareAndSet(keyVal, oldValue)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PluginStore.CompareAndSet(keyVal, oldValue)
		fmt.Println("RETRYING CompareAndSet")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) Delete(pluginId string, key string) *model.AppError {

	resultVar0 := s.PluginStore.Delete(pluginId, key)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PluginStore.Delete(pluginId, key)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerPluginStore) DeleteAllExpired() *model.AppError {

	resultVar0 := s.PluginStore.DeleteAllExpired()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PluginStore.DeleteAllExpired()
		fmt.Println("RETRYING DeleteAllExpired")
	}

	return resultVar0

}

func (s *RetryLayerPluginStore) DeleteAllForPlugin(PluginId string) *model.AppError {

	resultVar0 := s.PluginStore.DeleteAllForPlugin(PluginId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PluginStore.DeleteAllForPlugin(PluginId)
		fmt.Println("RETRYING DeleteAllForPlugin")
	}

	return resultVar0

}

func (s *RetryLayerPluginStore) Get(pluginId string, key string) (*model.PluginKeyValue, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.Get(pluginId, key)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PluginStore.Get(pluginId, key)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) List(pluginId string, page int, perPage int) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.List(pluginId, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PluginStore.List(pluginId, page, perPage)
		fmt.Println("RETRYING List")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.SaveOrUpdate(keyVal)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PluginStore.SaveOrUpdate(keyVal)
		fmt.Println("RETRYING SaveOrUpdate")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPluginStore) SetWithOptions(pluginId string, key string, value []byte, options model.PluginKVSetOptions) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.PluginStore.SetWithOptions(pluginId, key, value, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PluginStore.SetWithOptions(pluginId, key, value, options)
		fmt.Println("RETRYING SetWithOptions")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) AnalyticsPostCount(teamId string, mustHaveFile bool, mustHaveHashtag bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.AnalyticsPostCount(teamId, mustHaveFile, mustHaveHashtag)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.AnalyticsPostCount(teamId, mustHaveFile, mustHaveHashtag)
		fmt.Println("RETRYING AnalyticsPostCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) AnalyticsPostCountsByDay(options *model.AnalyticsPostCountsOptions) (model.AnalyticsRows, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.AnalyticsPostCountsByDay(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.AnalyticsPostCountsByDay(options)
		fmt.Println("RETRYING AnalyticsPostCountsByDay")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) AnalyticsUserCountsWithPostsByDay(teamId string) (model.AnalyticsRows, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.AnalyticsUserCountsWithPostsByDay(teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.AnalyticsUserCountsWithPostsByDay(teamId)
		fmt.Println("RETRYING AnalyticsUserCountsWithPostsByDay")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) ClearCaches() {

	s.PostStore.ClearCaches()
	return

}

func (s *RetryLayerPostStore) Delete(postId string, time int64, deleteByID string) *model.AppError {

	resultVar0 := s.PostStore.Delete(postId, time, deleteByID)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PostStore.Delete(postId, time, deleteByID)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerPostStore) Get(id string, skipFetchThreads bool) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Get(id, skipFetchThreads)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.Get(id, skipFetchThreads)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetDirectPostParentsForExportAfter(limit int, afterId string) ([]*model.DirectPostForExport, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetDirectPostParentsForExportAfter(limit, afterId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetDirectPostParentsForExportAfter(limit, afterId)
		fmt.Println("RETRYING GetDirectPostParentsForExportAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetEtag(channelId string, allowFromCache bool) string {

	resultVar0 := s.PostStore.GetEtag(channelId, allowFromCache)

	return resultVar0

}

func (s *RetryLayerPostStore) GetFlaggedPosts(userId string, offset int, limit int) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPosts(userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetFlaggedPosts(userId, offset, limit)
		fmt.Println("RETRYING GetFlaggedPosts")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetFlaggedPostsForChannel(userId string, channelId string, offset int, limit int) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPostsForChannel(userId, channelId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetFlaggedPostsForChannel(userId, channelId, offset, limit)
		fmt.Println("RETRYING GetFlaggedPostsForChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetFlaggedPostsForTeam(userId string, teamId string, offset int, limit int) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetFlaggedPostsForTeam(userId, teamId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetFlaggedPostsForTeam(userId, teamId, offset, limit)
		fmt.Println("RETRYING GetFlaggedPostsForTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetMaxPostSize() int {

	resultVar0 := s.PostStore.GetMaxPostSize()

	return resultVar0

}

func (s *RetryLayerPostStore) GetOldest() (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetOldest()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetOldest()
		fmt.Println("RETRYING GetOldest")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetOldestEntityCreationTime() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetOldestEntityCreationTime()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetOldestEntityCreationTime()
		fmt.Println("RETRYING GetOldestEntityCreationTime")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetParentsForExportAfter(limit int, afterId string) ([]*model.PostForExport, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetParentsForExportAfter(limit, afterId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetParentsForExportAfter(limit, afterId)
		fmt.Println("RETRYING GetParentsForExportAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostAfterTime(channelId string, time int64) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostAfterTime(channelId, time)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostAfterTime(channelId, time)
		fmt.Println("RETRYING GetPostAfterTime")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostIdAfterTime(channelId string, time int64) (string, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostIdAfterTime(channelId, time)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostIdAfterTime(channelId, time)
		fmt.Println("RETRYING GetPostIdAfterTime")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostIdBeforeTime(channelId string, time int64) (string, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostIdBeforeTime(channelId, time)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostIdBeforeTime(channelId, time)
		fmt.Println("RETRYING GetPostIdBeforeTime")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPosts(options model.GetPostsOptions, allowFromCache bool) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPosts(options, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPosts(options, allowFromCache)
		fmt.Println("RETRYING GetPosts")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsAfter(options model.GetPostsOptions) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsAfter(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostsAfter(options)
		fmt.Println("RETRYING GetPostsAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.PostForIndexing, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsBatchForIndexing(startTime, endTime, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostsBatchForIndexing(startTime, endTime, limit)
		fmt.Println("RETRYING GetPostsBatchForIndexing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsBefore(options model.GetPostsOptions) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsBefore(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostsBefore(options)
		fmt.Println("RETRYING GetPostsBefore")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsByIds(postIds []string) ([]*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsByIds(postIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostsByIds(postIds)
		fmt.Println("RETRYING GetPostsByIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsCreatedAt(channelId string, time int64) ([]*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsCreatedAt(channelId, time)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostsCreatedAt(channelId, time)
		fmt.Println("RETRYING GetPostsCreatedAt")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetPostsSince(options model.GetPostsSinceOptions, allowFromCache bool) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetPostsSince(options, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetPostsSince(options, allowFromCache)
		fmt.Println("RETRYING GetPostsSince")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetRepliesForExport(parentId string) ([]*model.ReplyForExport, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetRepliesForExport(parentId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetRepliesForExport(parentId)
		fmt.Println("RETRYING GetRepliesForExport")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) GetSingle(id string) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.GetSingle(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.GetSingle(id)
		fmt.Println("RETRYING GetSingle")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) InvalidateLastPostTimeCache(channelId string) {

	s.PostStore.InvalidateLastPostTimeCache(channelId)
	return

}

func (s *RetryLayerPostStore) Overwrite(post *model.Post) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Overwrite(post)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.Overwrite(post)
		fmt.Println("RETRYING Overwrite")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) OverwriteMultiple(posts []*model.Post) ([]*model.Post, int, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.PostStore.OverwriteMultiple(posts)

	for {
		if resultVar2 == nil || !strings.Contains(resultVar2.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1, resultVar2 = s.PostStore.OverwriteMultiple(posts)
		fmt.Println("RETRYING OverwriteMultiple")
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerPostStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.PermanentDeleteBatch(endTime, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.PermanentDeleteBatch(endTime, limit)
		fmt.Println("RETRYING PermanentDeleteBatch")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) PermanentDeleteByChannel(channelId string) *model.AppError {

	resultVar0 := s.PostStore.PermanentDeleteByChannel(channelId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PostStore.PermanentDeleteByChannel(channelId)
		fmt.Println("RETRYING PermanentDeleteByChannel")
	}

	return resultVar0

}

func (s *RetryLayerPostStore) PermanentDeleteByUser(userId string) *model.AppError {

	resultVar0 := s.PostStore.PermanentDeleteByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PostStore.PermanentDeleteByUser(userId)
		fmt.Println("RETRYING PermanentDeleteByUser")
	}

	return resultVar0

}

func (s *RetryLayerPostStore) Save(post *model.Post) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Save(post)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.Save(post)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) SaveMultiple(posts []*model.Post) ([]*model.Post, int, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.PostStore.SaveMultiple(posts)

	for {
		if resultVar2 == nil || !strings.Contains(resultVar2.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1, resultVar2 = s.PostStore.SaveMultiple(posts)
		fmt.Println("RETRYING SaveMultiple")
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerPostStore) Search(teamId string, userId string, params *model.SearchParams) (*model.PostList, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Search(teamId, userId, params)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.Search(teamId, userId, params)
		fmt.Println("RETRYING Search")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) SearchPostsInTeamForUser(paramsList []*model.SearchParams, userId string, teamId string, isOrSearch bool, includeDeletedChannels bool, page int, perPage int) (*model.PostSearchResults, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.SearchPostsInTeamForUser(paramsList, userId, teamId, isOrSearch, includeDeletedChannels, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.SearchPostsInTeamForUser(paramsList, userId, teamId, isOrSearch, includeDeletedChannels, page, perPage)
		fmt.Println("RETRYING SearchPostsInTeamForUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPostStore) Update(newPost *model.Post, oldPost *model.Post) (*model.Post, *model.AppError) {

	resultVar0, resultVar1 := s.PostStore.Update(newPost, oldPost)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PostStore.Update(newPost, oldPost)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.CleanupFlagsBatch(limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PreferenceStore.CleanupFlagsBatch(limit)
		fmt.Println("RETRYING CleanupFlagsBatch")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) Delete(userId string, category string, name string) *model.AppError {

	resultVar0 := s.PreferenceStore.Delete(userId, category, name)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PreferenceStore.Delete(userId, category, name)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) DeleteCategory(userId string, category string) *model.AppError {

	resultVar0 := s.PreferenceStore.DeleteCategory(userId, category)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PreferenceStore.DeleteCategory(userId, category)
		fmt.Println("RETRYING DeleteCategory")
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) DeleteCategoryAndName(category string, name string) *model.AppError {

	resultVar0 := s.PreferenceStore.DeleteCategoryAndName(category, name)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PreferenceStore.DeleteCategoryAndName(category, name)
		fmt.Println("RETRYING DeleteCategoryAndName")
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) Get(userId string, category string, name string) (*model.Preference, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.Get(userId, category, name)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PreferenceStore.Get(userId, category, name)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) GetAll(userId string) (model.Preferences, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.GetAll(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PreferenceStore.GetAll(userId)
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) GetCategory(userId string, category string) (model.Preferences, *model.AppError) {

	resultVar0, resultVar1 := s.PreferenceStore.GetCategory(userId, category)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.PreferenceStore.GetCategory(userId, category)
		fmt.Println("RETRYING GetCategory")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerPreferenceStore) PermanentDeleteByUser(userId string) *model.AppError {

	resultVar0 := s.PreferenceStore.PermanentDeleteByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PreferenceStore.PermanentDeleteByUser(userId)
		fmt.Println("RETRYING PermanentDeleteByUser")
	}

	return resultVar0

}

func (s *RetryLayerPreferenceStore) Save(preferences *model.Preferences) *model.AppError {

	resultVar0 := s.PreferenceStore.Save(preferences)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.PreferenceStore.Save(preferences)
		fmt.Println("RETRYING Save")
	}

	return resultVar0

}

func (s *RetryLayerReactionStore) BulkGetForPosts(postIds []string) ([]*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.BulkGetForPosts(postIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ReactionStore.BulkGetForPosts(postIds)
		fmt.Println("RETRYING BulkGetForPosts")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) Delete(reaction *model.Reaction) (*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.Delete(reaction)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ReactionStore.Delete(reaction)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) DeleteAllWithEmojiName(emojiName string) *model.AppError {

	resultVar0 := s.ReactionStore.DeleteAllWithEmojiName(emojiName)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.ReactionStore.DeleteAllWithEmojiName(emojiName)
		fmt.Println("RETRYING DeleteAllWithEmojiName")
	}

	return resultVar0

}

func (s *RetryLayerReactionStore) GetForPost(postId string, allowFromCache bool) ([]*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.GetForPost(postId, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ReactionStore.GetForPost(postId, allowFromCache)
		fmt.Println("RETRYING GetForPost")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.PermanentDeleteBatch(endTime, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ReactionStore.PermanentDeleteBatch(endTime, limit)
		fmt.Println("RETRYING PermanentDeleteBatch")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerReactionStore) Save(reaction *model.Reaction) (*model.Reaction, *model.AppError) {

	resultVar0, resultVar1 := s.ReactionStore.Save(reaction)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.ReactionStore.Save(reaction)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) AllChannelSchemeRoles() ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.AllChannelSchemeRoles()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.AllChannelSchemeRoles()
		fmt.Println("RETRYING AllChannelSchemeRoles")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) ChannelHigherScopedPermissions(roleNames []string) (map[string]*model.RolePermissions, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.ChannelHigherScopedPermissions(roleNames)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.ChannelHigherScopedPermissions(roleNames)
		fmt.Println("RETRYING ChannelHigherScopedPermissions")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) ChannelRolesUnderTeamRole(roleName string) ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.ChannelRolesUnderTeamRole(roleName)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.ChannelRolesUnderTeamRole(roleName)
		fmt.Println("RETRYING ChannelRolesUnderTeamRole")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) Delete(roleId string) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.Delete(roleId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.Delete(roleId)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) Get(roleId string) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.Get(roleId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.Get(roleId)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) GetAll() ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.GetAll()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.GetAll()
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) GetByName(name string) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.GetByName(name)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.GetByName(name)
		fmt.Println("RETRYING GetByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) GetByNames(names []string) ([]*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.GetByNames(names)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.GetByNames(names)
		fmt.Println("RETRYING GetByNames")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerRoleStore) PermanentDeleteAll() *model.AppError {

	resultVar0 := s.RoleStore.PermanentDeleteAll()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.RoleStore.PermanentDeleteAll()
		fmt.Println("RETRYING PermanentDeleteAll")
	}

	return resultVar0

}

func (s *RetryLayerRoleStore) Save(role *model.Role) (*model.Role, *model.AppError) {

	resultVar0, resultVar1 := s.RoleStore.Save(role)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.RoleStore.Save(role)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) CountByScope(scope string) (int64, error) {

	resultVar0, resultVar1 := s.SchemeStore.CountByScope(scope)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SchemeStore.CountByScope(scope)
		fmt.Println("RETRYING CountByScope")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) CountWithoutPermission(scope string, permissionID string, roleScope model.RoleScope, roleType model.RoleType) (int64, error) {

	resultVar0, resultVar1 := s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)
		fmt.Println("RETRYING CountWithoutPermission")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) Delete(schemeId string) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.Delete(schemeId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SchemeStore.Delete(schemeId)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) Get(schemeId string) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.Get(schemeId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SchemeStore.Get(schemeId)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) GetAllPage(scope string, offset int, limit int) ([]*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.GetAllPage(scope, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SchemeStore.GetAllPage(scope, offset, limit)
		fmt.Println("RETRYING GetAllPage")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) GetByName(schemeName string) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.GetByName(schemeName)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SchemeStore.GetByName(schemeName)
		fmt.Println("RETRYING GetByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSchemeStore) PermanentDeleteAll() error {

	resultVar0 := s.SchemeStore.PermanentDeleteAll()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SchemeStore.PermanentDeleteAll()
		fmt.Println("RETRYING PermanentDeleteAll")
	}

	return resultVar0

}

func (s *RetryLayerSchemeStore) Save(scheme *model.Scheme) (*model.Scheme, error) {

	resultVar0, resultVar1 := s.SchemeStore.Save(scheme)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SchemeStore.Save(scheme)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) AnalyticsSessionCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.AnalyticsSessionCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.AnalyticsSessionCount()
		fmt.Println("RETRYING AnalyticsSessionCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) {

	s.SessionStore.Cleanup(expiryTime, batchSize)
	return

}

func (s *RetryLayerSessionStore) Get(sessionIdOrToken string) (*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.Get(sessionIdOrToken)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.Get(sessionIdOrToken)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) GetSessions(userId string) ([]*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.GetSessions(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.GetSessions(userId)
		fmt.Println("RETRYING GetSessions")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)
		fmt.Println("RETRYING GetSessionsExpired")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) GetSessionsWithActiveDeviceIds(userId string) ([]*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.GetSessionsWithActiveDeviceIds(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.GetSessionsWithActiveDeviceIds(userId)
		fmt.Println("RETRYING GetSessionsWithActiveDeviceIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) PermanentDeleteSessionsByUser(teamId string) *model.AppError {

	resultVar0 := s.SessionStore.PermanentDeleteSessionsByUser(teamId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SessionStore.PermanentDeleteSessionsByUser(teamId)
		fmt.Println("RETRYING PermanentDeleteSessionsByUser")
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) Remove(sessionIdOrToken string) *model.AppError {

	resultVar0 := s.SessionStore.Remove(sessionIdOrToken)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SessionStore.Remove(sessionIdOrToken)
		fmt.Println("RETRYING Remove")
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) RemoveAllSessions() *model.AppError {

	resultVar0 := s.SessionStore.RemoveAllSessions()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SessionStore.RemoveAllSessions()
		fmt.Println("RETRYING RemoveAllSessions")
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) Save(session *model.Session) (*model.Session, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.Save(session)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.Save(session)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) UpdateDeviceId(id string, deviceId string, expiresAt int64) (string, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.UpdateDeviceId(id, deviceId, expiresAt)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.UpdateDeviceId(id, deviceId, expiresAt)
		fmt.Println("RETRYING UpdateDeviceId")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) *model.AppError {

	resultVar0 := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SessionStore.UpdateExpiredNotify(sessionid, notified)
		fmt.Println("RETRYING UpdateExpiredNotify")
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateExpiresAt(sessionId string, time int64) *model.AppError {

	resultVar0 := s.SessionStore.UpdateExpiresAt(sessionId, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SessionStore.UpdateExpiresAt(sessionId, time)
		fmt.Println("RETRYING UpdateExpiresAt")
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateLastActivityAt(sessionId string, time int64) *model.AppError {

	resultVar0 := s.SessionStore.UpdateLastActivityAt(sessionId, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SessionStore.UpdateLastActivityAt(sessionId, time)
		fmt.Println("RETRYING UpdateLastActivityAt")
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateProps(session *model.Session) *model.AppError {

	resultVar0 := s.SessionStore.UpdateProps(session)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SessionStore.UpdateProps(session)
		fmt.Println("RETRYING UpdateProps")
	}

	return resultVar0

}

func (s *RetryLayerSessionStore) UpdateRoles(userId string, roles string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.SessionStore.UpdateRoles(userId, roles)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SessionStore.UpdateRoles(userId, roles)
		fmt.Println("RETRYING UpdateRoles")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) Get(userId string) (*model.Status, *model.AppError) {

	resultVar0, resultVar1 := s.StatusStore.Get(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.StatusStore.Get(userId)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, *model.AppError) {

	resultVar0, resultVar1 := s.StatusStore.GetByIds(userIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.StatusStore.GetByIds(userIds)
		fmt.Println("RETRYING GetByIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) GetTotalActiveUsersCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.StatusStore.GetTotalActiveUsersCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.StatusStore.GetTotalActiveUsersCount()
		fmt.Println("RETRYING GetTotalActiveUsersCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerStatusStore) ResetAll() *model.AppError {

	resultVar0 := s.StatusStore.ResetAll()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.StatusStore.ResetAll()
		fmt.Println("RETRYING ResetAll")
	}

	return resultVar0

}

func (s *RetryLayerStatusStore) SaveOrUpdate(status *model.Status) *model.AppError {

	resultVar0 := s.StatusStore.SaveOrUpdate(status)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.StatusStore.SaveOrUpdate(status)
		fmt.Println("RETRYING SaveOrUpdate")
	}

	return resultVar0

}

func (s *RetryLayerStatusStore) UpdateLastActivityAt(userId string, lastActivityAt int64) *model.AppError {

	resultVar0 := s.StatusStore.UpdateLastActivityAt(userId, lastActivityAt)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.StatusStore.UpdateLastActivityAt(userId, lastActivityAt)
		fmt.Println("RETRYING UpdateLastActivityAt")
	}

	return resultVar0

}

func (s *RetryLayerSystemStore) Get() (model.StringMap, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.Get()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SystemStore.Get()
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) GetByName(name string) (*model.System, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.GetByName(name)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SystemStore.GetByName(name)
		fmt.Println("RETRYING GetByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) InsertIfExists(system *model.System) (*model.System, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.InsertIfExists(system)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SystemStore.InsertIfExists(system)
		fmt.Println("RETRYING InsertIfExists")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) PermanentDeleteByName(name string) (*model.System, *model.AppError) {

	resultVar0, resultVar1 := s.SystemStore.PermanentDeleteByName(name)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.SystemStore.PermanentDeleteByName(name)
		fmt.Println("RETRYING PermanentDeleteByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerSystemStore) Save(system *model.System) *model.AppError {

	resultVar0 := s.SystemStore.Save(system)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SystemStore.Save(system)
		fmt.Println("RETRYING Save")
	}

	return resultVar0

}

func (s *RetryLayerSystemStore) SaveOrUpdate(system *model.System) *model.AppError {

	resultVar0 := s.SystemStore.SaveOrUpdate(system)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SystemStore.SaveOrUpdate(system)
		fmt.Println("RETRYING SaveOrUpdate")
	}

	return resultVar0

}

func (s *RetryLayerSystemStore) Update(system *model.System) *model.AppError {

	resultVar0 := s.SystemStore.Update(system)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.SystemStore.Update(system)
		fmt.Println("RETRYING Update")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) AnalyticsGetTeamCountForScheme(schemeId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsGetTeamCountForScheme(schemeId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.AnalyticsGetTeamCountForScheme(schemeId)
		fmt.Println("RETRYING AnalyticsGetTeamCountForScheme")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) AnalyticsPrivateTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsPrivateTeamCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.AnalyticsPrivateTeamCount()
		fmt.Println("RETRYING AnalyticsPrivateTeamCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) AnalyticsPublicTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsPublicTeamCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.AnalyticsPublicTeamCount()
		fmt.Println("RETRYING AnalyticsPublicTeamCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) AnalyticsTeamCount(includeDeleted bool) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.AnalyticsTeamCount(includeDeleted)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.AnalyticsTeamCount(includeDeleted)
		fmt.Println("RETRYING AnalyticsTeamCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) ClearAllCustomRoleAssignments() *model.AppError {

	resultVar0 := s.TeamStore.ClearAllCustomRoleAssignments()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.ClearAllCustomRoleAssignments()
		fmt.Println("RETRYING ClearAllCustomRoleAssignments")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) ClearCaches() {

	s.TeamStore.ClearCaches()
	return

}

func (s *RetryLayerTeamStore) Get(id string) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetActiveMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetActiveMemberCount(teamId, restrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetActiveMemberCount(teamId, restrictions)
		fmt.Println("RETRYING GetActiveMemberCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAll() ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAll()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAll()
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllForExportAfter(limit int, afterId string) ([]*model.TeamForExport, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllForExportAfter(limit, afterId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAllForExportAfter(limit, afterId)
		fmt.Println("RETRYING GetAllForExportAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPage(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPage(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAllPage(offset, limit)
		fmt.Println("RETRYING GetAllPage")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPrivateTeamListing() ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPrivateTeamListing()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAllPrivateTeamListing()
		fmt.Println("RETRYING GetAllPrivateTeamListing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPrivateTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPrivateTeamPageListing(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAllPrivateTeamPageListing(offset, limit)
		fmt.Println("RETRYING GetAllPrivateTeamPageListing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllPublicTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllPublicTeamPageListing(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAllPublicTeamPageListing(offset, limit)
		fmt.Println("RETRYING GetAllPublicTeamPageListing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllTeamListing() ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllTeamListing()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAllTeamListing()
		fmt.Println("RETRYING GetAllTeamListing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetAllTeamPageListing(offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetAllTeamPageListing(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetAllTeamPageListing(offset, limit)
		fmt.Println("RETRYING GetAllTeamPageListing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetByInviteId(inviteId string) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetByInviteId(inviteId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetByInviteId(inviteId)
		fmt.Println("RETRYING GetByInviteId")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetByName(name string) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetByName(name)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetByName(name)
		fmt.Println("RETRYING GetByName")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetByNames(name []string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetByNames(name)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetByNames(name)
		fmt.Println("RETRYING GetByNames")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetChannelUnreadsForAllTeams(excludeTeamId string, userId string) ([]*model.ChannelUnread, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamId, userId)
		fmt.Println("RETRYING GetChannelUnreadsForAllTeams")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetChannelUnreadsForTeam(teamId string, userId string) ([]*model.ChannelUnread, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetChannelUnreadsForTeam(teamId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetChannelUnreadsForTeam(teamId, userId)
		fmt.Println("RETRYING GetChannelUnreadsForTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetMember(teamId string, userId string) (*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetMember(teamId, userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetMember(teamId, userId)
		fmt.Println("RETRYING GetMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetMembers(teamId string, offset int, limit int, teamMembersGetOptions *model.TeamMembersGetOptions) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetMembers(teamId, offset, limit, teamMembersGetOptions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetMembers(teamId, offset, limit, teamMembersGetOptions)
		fmt.Println("RETRYING GetMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetMembersByIds(teamId string, userIds []string, restrictions *model.ViewUsersRestrictions) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetMembersByIds(teamId, userIds, restrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetMembersByIds(teamId, userIds, restrictions)
		fmt.Println("RETRYING GetMembersByIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamMembersForExport(userId string) ([]*model.TeamMemberForExport, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamMembersForExport(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetTeamMembersForExport(userId)
		fmt.Println("RETRYING GetTeamMembersForExport")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsByScheme(schemeId string, offset int, limit int) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsByScheme(schemeId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetTeamsByScheme(schemeId, offset, limit)
		fmt.Println("RETRYING GetTeamsByScheme")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsByUserId(userId string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsByUserId(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetTeamsByUserId(userId)
		fmt.Println("RETRYING GetTeamsByUserId")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsForUser(userId string) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsForUser(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetTeamsForUser(userId)
		fmt.Println("RETRYING GetTeamsForUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTeamsForUserWithPagination(userId string, page int, perPage int) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTeamsForUserWithPagination(userId, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetTeamsForUserWithPagination(userId, page, perPage)
		fmt.Println("RETRYING GetTeamsForUserWithPagination")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetTotalMemberCount(teamId string, restrictions *model.ViewUsersRestrictions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetTotalMemberCount(teamId, restrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetTotalMemberCount(teamId, restrictions)
		fmt.Println("RETRYING GetTotalMemberCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GetUserTeamIds(userId string, allowFromCache bool) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GetUserTeamIds(userId, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GetUserTeamIds(userId, allowFromCache)
		fmt.Println("RETRYING GetUserTeamIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) GroupSyncedTeamCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.GroupSyncedTeamCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.GroupSyncedTeamCount()
		fmt.Println("RETRYING GroupSyncedTeamCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) InvalidateAllTeamIdsForUser(userId string) {

	s.TeamStore.InvalidateAllTeamIdsForUser(userId)
	return

}

func (s *RetryLayerTeamStore) MigrateTeamMembers(fromTeamId string, fromUserId string) (map[string]string, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.MigrateTeamMembers(fromTeamId, fromUserId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.MigrateTeamMembers(fromTeamId, fromUserId)
		fmt.Println("RETRYING MigrateTeamMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) PermanentDelete(teamId string) *model.AppError {

	resultVar0 := s.TeamStore.PermanentDelete(teamId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.PermanentDelete(teamId)
		fmt.Println("RETRYING PermanentDelete")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveAllMembersByTeam(teamId string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveAllMembersByTeam(teamId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.RemoveAllMembersByTeam(teamId)
		fmt.Println("RETRYING RemoveAllMembersByTeam")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveAllMembersByUser(userId string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveAllMembersByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.RemoveAllMembersByUser(userId)
		fmt.Println("RETRYING RemoveAllMembersByUser")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveMember(teamId string, userId string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveMember(teamId, userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.RemoveMember(teamId, userId)
		fmt.Println("RETRYING RemoveMember")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) RemoveMembers(teamId string, userIds []string) *model.AppError {

	resultVar0 := s.TeamStore.RemoveMembers(teamId, userIds)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.RemoveMembers(teamId, userIds)
		fmt.Println("RETRYING RemoveMembers")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) ResetAllTeamSchemes() *model.AppError {

	resultVar0 := s.TeamStore.ResetAllTeamSchemes()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.ResetAllTeamSchemes()
		fmt.Println("RETRYING ResetAllTeamSchemes")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) Save(team *model.Team) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.Save(team)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.Save(team)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SaveMember(member *model.TeamMember, maxUsersPerTeam int) (*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SaveMember(member, maxUsersPerTeam)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.SaveMember(member, maxUsersPerTeam)
		fmt.Println("RETRYING SaveMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)
		fmt.Println("RETRYING SaveMultipleMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SearchAll(term string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SearchAll(term)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.SearchAll(term)
		fmt.Println("RETRYING SearchAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SearchAllPaged(term string, page int, perPage int) ([]*model.Team, int64, *model.AppError) {

	resultVar0, resultVar1, resultVar2 := s.TeamStore.SearchAllPaged(term, page, perPage)

	for {
		if resultVar2 == nil || !strings.Contains(resultVar2.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1, resultVar2 = s.TeamStore.SearchAllPaged(term, page, perPage)
		fmt.Println("RETRYING SearchAllPaged")
	}

	return resultVar0, resultVar1, resultVar2

}

func (s *RetryLayerTeamStore) SearchOpen(term string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SearchOpen(term)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.SearchOpen(term)
		fmt.Println("RETRYING SearchOpen")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) SearchPrivate(term string) ([]*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.SearchPrivate(term)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.SearchPrivate(term)
		fmt.Println("RETRYING SearchPrivate")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) Update(team *model.Team) (*model.Team, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.Update(team)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.Update(team)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) UpdateLastTeamIconUpdate(teamId string, curTime int64) *model.AppError {

	resultVar0 := s.TeamStore.UpdateLastTeamIconUpdate(teamId, curTime)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.UpdateLastTeamIconUpdate(teamId, curTime)
		fmt.Println("RETRYING UpdateLastTeamIconUpdate")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) UpdateMember(member *model.TeamMember) (*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.UpdateMember(member)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.UpdateMember(member)
		fmt.Println("RETRYING UpdateMember")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) UpdateMembersRole(teamID string, userIDs []string) *model.AppError {

	resultVar0 := s.TeamStore.UpdateMembersRole(teamID, userIDs)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TeamStore.UpdateMembersRole(teamID, userIDs)
		fmt.Println("RETRYING UpdateMembersRole")
	}

	return resultVar0

}

func (s *RetryLayerTeamStore) UpdateMultipleMembers(members []*model.TeamMember) ([]*model.TeamMember, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.UpdateMultipleMembers(members)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.UpdateMultipleMembers(members)
		fmt.Println("RETRYING UpdateMultipleMembers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTeamStore) UserBelongsToTeams(userId string, teamIds []string) (bool, *model.AppError) {

	resultVar0, resultVar1 := s.TeamStore.UserBelongsToTeams(userId, teamIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TeamStore.UserBelongsToTeams(userId, teamIds)
		fmt.Println("RETRYING UserBelongsToTeams")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {

	resultVar0, resultVar1 := s.TermsOfServiceStore.Get(id, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TermsOfServiceStore.Get(id, allowFromCache)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {

	resultVar0, resultVar1 := s.TermsOfServiceStore.GetLatest(allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TermsOfServiceStore.GetLatest(allowFromCache)
		fmt.Println("RETRYING GetLatest")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {

	resultVar0, resultVar1 := s.TermsOfServiceStore.Save(termsOfService)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TermsOfServiceStore.Save(termsOfService)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTokenStore) Cleanup() {

	s.TokenStore.Cleanup()
	return

}

func (s *RetryLayerTokenStore) Delete(token string) *model.AppError {

	resultVar0 := s.TokenStore.Delete(token)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TokenStore.Delete(token)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerTokenStore) GetByToken(token string) (*model.Token, *model.AppError) {

	resultVar0, resultVar1 := s.TokenStore.GetByToken(token)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.TokenStore.GetByToken(token)
		fmt.Println("RETRYING GetByToken")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerTokenStore) RemoveAllTokensByType(tokenType string) *model.AppError {

	resultVar0 := s.TokenStore.RemoveAllTokensByType(tokenType)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TokenStore.RemoveAllTokensByType(tokenType)
		fmt.Println("RETRYING RemoveAllTokensByType")
	}

	return resultVar0

}

func (s *RetryLayerTokenStore) Save(recovery *model.Token) *model.AppError {

	resultVar0 := s.TokenStore.Save(recovery)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.TokenStore.Save(recovery)
		fmt.Println("RETRYING Save")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) AnalyticsActiveCount(time int64, options model.UserCountOptions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsActiveCount(time, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.AnalyticsActiveCount(time, options)
		fmt.Println("RETRYING AnalyticsActiveCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AnalyticsGetGuestCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetGuestCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.AnalyticsGetGuestCount()
		fmt.Println("RETRYING AnalyticsGetGuestCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetInactiveUsersCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.AnalyticsGetInactiveUsersCount()
		fmt.Println("RETRYING AnalyticsGetInactiveUsersCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AnalyticsGetSystemAdminCount() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AnalyticsGetSystemAdminCount()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.AnalyticsGetSystemAdminCount()
		fmt.Println("RETRYING AnalyticsGetSystemAdminCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) AutocompleteUsersInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) (*model.UserAutocompleteInChannel, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.AutocompleteUsersInChannel(teamId, channelId, term, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.AutocompleteUsersInChannel(teamId, channelId, term, options)
		fmt.Println("RETRYING AutocompleteUsersInChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) ClearAllCustomRoleAssignments() *model.AppError {

	resultVar0 := s.UserStore.ClearAllCustomRoleAssignments()

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.ClearAllCustomRoleAssignments()
		fmt.Println("RETRYING ClearAllCustomRoleAssignments")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) ClearCaches() {

	s.UserStore.ClearCaches()
	return

}

func (s *RetryLayerUserStore) Count(options model.UserCountOptions) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Count(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.Count(options)
		fmt.Println("RETRYING Count")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) DeactivateGuests() ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.DeactivateGuests()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.DeactivateGuests()
		fmt.Println("RETRYING DeactivateGuests")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) DemoteUserToGuest(userID string) *model.AppError {

	resultVar0 := s.UserStore.DemoteUserToGuest(userID)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.DemoteUserToGuest(userID)
		fmt.Println("RETRYING DemoteUserToGuest")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) Get(id string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Get(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.Get(id)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAll() ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAll()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetAll()
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllAfter(limit int, afterId string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllAfter(limit, afterId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetAllAfter(limit, afterId)
		fmt.Println("RETRYING GetAllAfter")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllNotInAuthService(authServices)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetAllNotInAuthService(authServices)
		fmt.Println("RETRYING GetAllNotInAuthService")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllProfiles(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetAllProfiles(options)
		fmt.Println("RETRYING GetAllProfiles")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllProfilesInChannel(channelId string, allowFromCache bool) (map[string]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllProfilesInChannel(channelId, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetAllProfilesInChannel(channelId, allowFromCache)
		fmt.Println("RETRYING GetAllProfilesInChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAllUsingAuthService(authService)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetAllUsingAuthService(authService)
		fmt.Println("RETRYING GetAllUsingAuthService")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetAnyUnreadPostCountForChannel(userId string, channelId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetAnyUnreadPostCountForChannel(userId, channelId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetAnyUnreadPostCountForChannel(userId, channelId)
		fmt.Println("RETRYING GetAnyUnreadPostCountForChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetByAuth(authData, authService)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetByAuth(authData, authService)
		fmt.Println("RETRYING GetByAuth")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetByEmail(email string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetByEmail(email)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetByEmail(email)
		fmt.Println("RETRYING GetByEmail")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetByUsername(username string) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetByUsername(username)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetByUsername(username)
		fmt.Println("RETRYING GetByUsername")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetChannelGroupUsers(channelID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetChannelGroupUsers(channelID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetChannelGroupUsers(channelID)
		fmt.Println("RETRYING GetChannelGroupUsers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetEtagForAllProfiles() string {

	resultVar0 := s.UserStore.GetEtagForAllProfiles()

	return resultVar0

}

func (s *RetryLayerUserStore) GetEtagForProfiles(teamId string) string {

	resultVar0 := s.UserStore.GetEtagForProfiles(teamId)

	return resultVar0

}

func (s *RetryLayerUserStore) GetEtagForProfilesNotInTeam(teamId string) string {

	resultVar0 := s.UserStore.GetEtagForProfilesNotInTeam(teamId)

	return resultVar0

}

func (s *RetryLayerUserStore) GetForLogin(loginId string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetForLogin(loginId, allowSignInWithUsername, allowSignInWithEmail)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetForLogin(loginId, allowSignInWithUsername, allowSignInWithEmail)
		fmt.Println("RETRYING GetForLogin")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetKnownUsers(userID string) ([]string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetKnownUsers(userID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetKnownUsers(userID)
		fmt.Println("RETRYING GetKnownUsers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetNewUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetNewUsersForTeam(teamId, offset, limit, viewRestrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetNewUsersForTeam(teamId, offset, limit, viewRestrictions)
		fmt.Println("RETRYING GetNewUsersForTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfileByGroupChannelIdsForUser(userId string, channelIds []string) (map[string][]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfileByGroupChannelIdsForUser(userId, channelIds)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfileByGroupChannelIdsForUser(userId, channelIds)
		fmt.Println("RETRYING GetProfileByGroupChannelIdsForUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfileByIds(userIds []string, options *UserGetByIdsOpts, allowFromCache bool) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfileByIds(userIds, options, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfileByIds(userIds, options, allowFromCache)
		fmt.Println("RETRYING GetProfileByIds")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfiles(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfiles(options)
		fmt.Println("RETRYING GetProfiles")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesByUsernames(usernames []string, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)
		fmt.Println("RETRYING GetProfilesByUsernames")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesInChannel(channelId string, offset int, limit int) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesInChannel(channelId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfilesInChannel(channelId, offset, limit)
		fmt.Println("RETRYING GetProfilesInChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesInChannelByStatus(channelId string, offset int, limit int) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesInChannelByStatus(channelId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfilesInChannelByStatus(channelId, offset, limit)
		fmt.Println("RETRYING GetProfilesInChannelByStatus")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesNotInChannel(teamId string, channelId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfilesNotInChannel(teamId, channelId, groupConstrained, offset, limit, viewRestrictions)
		fmt.Println("RETRYING GetProfilesNotInChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesNotInTeam(teamId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesNotInTeam(teamId, groupConstrained, offset, limit, viewRestrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfilesNotInTeam(teamId, groupConstrained, offset, limit, viewRestrictions)
		fmt.Println("RETRYING GetProfilesNotInTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetProfilesWithoutTeam(options *model.UserGetOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetProfilesWithoutTeam(options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetProfilesWithoutTeam(options)
		fmt.Println("RETRYING GetProfilesWithoutTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetRecentlyActiveUsersForTeam(teamId string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetRecentlyActiveUsersForTeam(teamId, offset, limit, viewRestrictions)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetRecentlyActiveUsersForTeam(teamId, offset, limit, viewRestrictions)
		fmt.Println("RETRYING GetRecentlyActiveUsersForTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetSystemAdminProfiles()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetSystemAdminProfiles()
		fmt.Println("RETRYING GetSystemAdminProfiles")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetTeamGroupUsers(teamID string) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetTeamGroupUsers(teamID)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetTeamGroupUsers(teamID)
		fmt.Println("RETRYING GetTeamGroupUsers")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetUnreadCount(userId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetUnreadCount(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetUnreadCount(userId)
		fmt.Println("RETRYING GetUnreadCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetUnreadCountForChannel(userId string, channelId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetUnreadCountForChannel(userId, channelId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetUnreadCountForChannel(userId, channelId)
		fmt.Println("RETRYING GetUnreadCountForChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) GetUsersBatchForIndexing(startTime int64, endTime int64, limit int) ([]*model.UserForIndexing, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.GetUsersBatchForIndexing(startTime, endTime, limit)
		fmt.Println("RETRYING GetUsersBatchForIndexing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) InferSystemInstallDate() (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.InferSystemInstallDate()

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.InferSystemInstallDate()
		fmt.Println("RETRYING InferSystemInstallDate")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) InvalidateProfileCacheForUser(userId string) {

	s.UserStore.InvalidateProfileCacheForUser(userId)
	return

}

func (s *RetryLayerUserStore) InvalidateProfilesInChannelCache(channelId string) {

	s.UserStore.InvalidateProfilesInChannelCache(channelId)
	return

}

func (s *RetryLayerUserStore) InvalidateProfilesInChannelCacheByUser(userId string) {

	s.UserStore.InvalidateProfilesInChannelCacheByUser(userId)
	return

}

func (s *RetryLayerUserStore) PermanentDelete(userId string) *model.AppError {

	resultVar0 := s.UserStore.PermanentDelete(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.PermanentDelete(userId)
		fmt.Println("RETRYING PermanentDelete")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) PromoteGuestToUser(userID string) *model.AppError {

	resultVar0 := s.UserStore.PromoteGuestToUser(userID)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.PromoteGuestToUser(userID)
		fmt.Println("RETRYING PromoteGuestToUser")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) ResetLastPictureUpdate(userId string) *model.AppError {

	resultVar0 := s.UserStore.ResetLastPictureUpdate(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.ResetLastPictureUpdate(userId)
		fmt.Println("RETRYING ResetLastPictureUpdate")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) Save(user *model.User) (*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Save(user)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.Save(user)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) Search(teamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Search(teamId, term, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.Search(teamId, term, options)
		fmt.Println("RETRYING Search")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchInChannel(channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchInChannel(channelId, term, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.SearchInChannel(channelId, term, options)
		fmt.Println("RETRYING SearchInChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchInGroup(groupID, term, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.SearchInGroup(groupID, term, options)
		fmt.Println("RETRYING SearchInGroup")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchNotInChannel(teamId string, channelId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchNotInChannel(teamId, channelId, term, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.SearchNotInChannel(teamId, channelId, term, options)
		fmt.Println("RETRYING SearchNotInChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchNotInTeam(notInTeamId string, term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchNotInTeam(notInTeamId, term, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.SearchNotInTeam(notInTeamId, term, options)
		fmt.Println("RETRYING SearchNotInTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) SearchWithoutTeam(term string, options *model.UserSearchOptions) ([]*model.User, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.SearchWithoutTeam(term, options)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.SearchWithoutTeam(term, options)
		fmt.Println("RETRYING SearchWithoutTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.Update(user, allowRoleUpdate)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.Update(user, allowRoleUpdate)
		fmt.Println("RETRYING Update")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) UpdateAuthData(userId string, service string, authData *string, email string, resetMfa bool) (string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.UpdateAuthData(userId, service, authData, email, resetMfa)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.UpdateAuthData(userId, service, authData, email, resetMfa)
		fmt.Println("RETRYING UpdateAuthData")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) UpdateFailedPasswordAttempts(userId string, attempts int) *model.AppError {

	resultVar0 := s.UserStore.UpdateFailedPasswordAttempts(userId, attempts)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.UpdateFailedPasswordAttempts(userId, attempts)
		fmt.Println("RETRYING UpdateFailedPasswordAttempts")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateLastPictureUpdate(userId string) *model.AppError {

	resultVar0 := s.UserStore.UpdateLastPictureUpdate(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.UpdateLastPictureUpdate(userId)
		fmt.Println("RETRYING UpdateLastPictureUpdate")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateMfaActive(userId string, active bool) *model.AppError {

	resultVar0 := s.UserStore.UpdateMfaActive(userId, active)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.UpdateMfaActive(userId, active)
		fmt.Println("RETRYING UpdateMfaActive")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateMfaSecret(userId string, secret string) *model.AppError {

	resultVar0 := s.UserStore.UpdateMfaSecret(userId, secret)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.UpdateMfaSecret(userId, secret)
		fmt.Println("RETRYING UpdateMfaSecret")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdatePassword(userId string, newPassword string) *model.AppError {

	resultVar0 := s.UserStore.UpdatePassword(userId, newPassword)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserStore.UpdatePassword(userId, newPassword)
		fmt.Println("RETRYING UpdatePassword")
	}

	return resultVar0

}

func (s *RetryLayerUserStore) UpdateUpdateAt(userId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.UpdateUpdateAt(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.UpdateUpdateAt(userId)
		fmt.Println("RETRYING UpdateUpdateAt")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserStore) VerifyEmail(userId string, email string) (string, *model.AppError) {

	resultVar0, resultVar1 := s.UserStore.VerifyEmail(userId, email)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserStore.VerifyEmail(userId, email)
		fmt.Println("RETRYING VerifyEmail")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) Delete(tokenId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.Delete(tokenId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserAccessTokenStore.Delete(tokenId)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerUserAccessTokenStore) DeleteAllForUser(userId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.DeleteAllForUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserAccessTokenStore.DeleteAllForUser(userId)
		fmt.Println("RETRYING DeleteAllForUser")
	}

	return resultVar0

}

func (s *RetryLayerUserAccessTokenStore) Get(tokenId string) (*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.Get(tokenId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserAccessTokenStore.Get(tokenId)
		fmt.Println("RETRYING Get")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetAll(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserAccessTokenStore.GetAll(offset, limit)
		fmt.Println("RETRYING GetAll")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetByToken(tokenString)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserAccessTokenStore.GetByToken(tokenString)
		fmt.Println("RETRYING GetByToken")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) GetByUser(userId string, page int, perPage int) ([]*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.GetByUser(userId, page, perPage)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserAccessTokenStore.GetByUser(userId, page, perPage)
		fmt.Println("RETRYING GetByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.Save(token)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserAccessTokenStore.Save(token)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, *model.AppError) {

	resultVar0, resultVar1 := s.UserAccessTokenStore.Search(term)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserAccessTokenStore.Search(term)
		fmt.Println("RETRYING Search")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenDisable(tokenId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.UpdateTokenDisable(tokenId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserAccessTokenStore.UpdateTokenDisable(tokenId)
		fmt.Println("RETRYING UpdateTokenDisable")
	}

	return resultVar0

}

func (s *RetryLayerUserAccessTokenStore) UpdateTokenEnable(tokenId string) *model.AppError {

	resultVar0 := s.UserAccessTokenStore.UpdateTokenEnable(tokenId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserAccessTokenStore.UpdateTokenEnable(tokenId)
		fmt.Println("RETRYING UpdateTokenEnable")
	}

	return resultVar0

}

func (s *RetryLayerUserTermsOfServiceStore) Delete(userId string, termsOfServiceId string) error {

	resultVar0 := s.UserTermsOfServiceStore.Delete(userId, termsOfServiceId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.UserTermsOfServiceStore.Delete(userId, termsOfServiceId)
		fmt.Println("RETRYING Delete")
	}

	return resultVar0

}

func (s *RetryLayerUserTermsOfServiceStore) GetByUser(userId string) (*model.UserTermsOfService, error) {

	resultVar0, resultVar1 := s.UserTermsOfServiceStore.GetByUser(userId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserTermsOfServiceStore.GetByUser(userId)
		fmt.Println("RETRYING GetByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerUserTermsOfServiceStore) Save(userTermsOfService *model.UserTermsOfService) (*model.UserTermsOfService, error) {

	resultVar0, resultVar1 := s.UserTermsOfServiceStore.Save(userTermsOfService)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.UserTermsOfServiceStore.Save(userTermsOfService)
		fmt.Println("RETRYING Save")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) AnalyticsIncomingCount(teamId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.AnalyticsIncomingCount(teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.AnalyticsIncomingCount(teamId)
		fmt.Println("RETRYING AnalyticsIncomingCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) AnalyticsOutgoingCount(teamId string) (int64, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.AnalyticsOutgoingCount(teamId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.AnalyticsOutgoingCount(teamId)
		fmt.Println("RETRYING AnalyticsOutgoingCount")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) ClearCaches() {

	s.WebhookStore.ClearCaches()
	return

}

func (s *RetryLayerWebhookStore) DeleteIncoming(webhookId string, time int64) *model.AppError {

	resultVar0 := s.WebhookStore.DeleteIncoming(webhookId, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.WebhookStore.DeleteIncoming(webhookId, time)
		fmt.Println("RETRYING DeleteIncoming")
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) DeleteOutgoing(webhookId string, time int64) *model.AppError {

	resultVar0 := s.WebhookStore.DeleteOutgoing(webhookId, time)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.WebhookStore.DeleteOutgoing(webhookId, time)
		fmt.Println("RETRYING DeleteOutgoing")
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) GetIncoming(id string, allowFromCache bool) (*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncoming(id, allowFromCache)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetIncoming(id, allowFromCache)
		fmt.Println("RETRYING GetIncoming")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingByChannel(channelId string) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByChannel(channelId)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetIncomingByChannel(channelId)
		fmt.Println("RETRYING GetIncomingByChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingByTeam(teamId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByTeam(teamId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetIncomingByTeam(teamId, offset, limit)
		fmt.Println("RETRYING GetIncomingByTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingByTeamByUser(teamId, userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetIncomingByTeamByUser(teamId, userId, offset, limit)
		fmt.Println("RETRYING GetIncomingByTeamByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingList(offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingList(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetIncomingList(offset, limit)
		fmt.Println("RETRYING GetIncomingList")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetIncomingListByUser(userId string, offset int, limit int) ([]*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetIncomingListByUser(userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetIncomingListByUser(userId, offset, limit)
		fmt.Println("RETRYING GetIncomingListByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoing(id string) (*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoing(id)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetOutgoing(id)
		fmt.Println("RETRYING GetOutgoing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByChannel(channelId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByChannel(channelId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByChannel(channelId, offset, limit)
		fmt.Println("RETRYING GetOutgoingByChannel")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByChannelByUser(channelId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByChannelByUser(channelId, userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByChannelByUser(channelId, userId, offset, limit)
		fmt.Println("RETRYING GetOutgoingByChannelByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByTeam(teamId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByTeam(teamId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByTeam(teamId, offset, limit)
		fmt.Println("RETRYING GetOutgoingByTeam")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingByTeamByUser(teamId string, userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingByTeamByUser(teamId, userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingByTeamByUser(teamId, userId, offset, limit)
		fmt.Println("RETRYING GetOutgoingByTeamByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingList(offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingList(offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingList(offset, limit)
		fmt.Println("RETRYING GetOutgoingList")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) GetOutgoingListByUser(userId string, offset int, limit int) ([]*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.GetOutgoingListByUser(userId, offset, limit)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.GetOutgoingListByUser(userId, offset, limit)
		fmt.Println("RETRYING GetOutgoingListByUser")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) InvalidateWebhookCache(webhook string) {

	s.WebhookStore.InvalidateWebhookCache(webhook)
	return

}

func (s *RetryLayerWebhookStore) PermanentDeleteIncomingByChannel(channelId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteIncomingByChannel(channelId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.WebhookStore.PermanentDeleteIncomingByChannel(channelId)
		fmt.Println("RETRYING PermanentDeleteIncomingByChannel")
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) PermanentDeleteIncomingByUser(userId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteIncomingByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.WebhookStore.PermanentDeleteIncomingByUser(userId)
		fmt.Println("RETRYING PermanentDeleteIncomingByUser")
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) PermanentDeleteOutgoingByChannel(channelId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteOutgoingByChannel(channelId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.WebhookStore.PermanentDeleteOutgoingByChannel(channelId)
		fmt.Println("RETRYING PermanentDeleteOutgoingByChannel")
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) PermanentDeleteOutgoingByUser(userId string) *model.AppError {

	resultVar0 := s.WebhookStore.PermanentDeleteOutgoingByUser(userId)

	for {
		if resultVar0 == nil || !strings.Contains(resultVar0.Error(), "TransactionRetryError") {
			break
		}
		resultVar0 = s.WebhookStore.PermanentDeleteOutgoingByUser(userId)
		fmt.Println("RETRYING PermanentDeleteOutgoingByUser")
	}

	return resultVar0

}

func (s *RetryLayerWebhookStore) SaveIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.SaveIncoming(webhook)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.SaveIncoming(webhook)
		fmt.Println("RETRYING SaveIncoming")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) SaveOutgoing(webhook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.SaveOutgoing(webhook)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.SaveOutgoing(webhook)
		fmt.Println("RETRYING SaveOutgoing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) UpdateIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.UpdateIncoming(webhook)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.UpdateIncoming(webhook)
		fmt.Println("RETRYING UpdateIncoming")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayerWebhookStore) UpdateOutgoing(hook *model.OutgoingWebhook) (*model.OutgoingWebhook, *model.AppError) {

	resultVar0, resultVar1 := s.WebhookStore.UpdateOutgoing(hook)

	for {
		if resultVar1 == nil || !strings.Contains(resultVar1.Error(), "TransactionRetryError") {
			break
		}
		resultVar0, resultVar1 = s.WebhookStore.UpdateOutgoing(hook)
		fmt.Println("RETRYING UpdateOutgoing")
	}

	return resultVar0, resultVar1

}

func (s *RetryLayer) Close() {
	s.Store.Close()
}

func (s *RetryLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *RetryLayer) GetCurrentSchemaVersion() string {
	return s.Store.GetCurrentSchemaVersion()
}

func (s *RetryLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *RetryLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *RetryLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *RetryLayer) TotalMasterDbConnections() int {
	return s.Store.TotalMasterDbConnections()
}

func (s *RetryLayer) TotalReadDbConnections() int {
	return s.Store.TotalReadDbConnections()
}

func (s *RetryLayer) TotalSearchDbConnections() int {
	return s.Store.TotalSearchDbConnections()
}

func (s *RetryLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func NewRetryLayer(childStore Store) *RetryLayer {
	newStore := RetryLayer{
		Store: childStore,
	}

	newStore.AuditStore = &RetryLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.BotStore = &RetryLayerBotStore{BotStore: childStore.Bot(), Root: &newStore}
	newStore.ChannelStore = &RetryLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.ChannelMemberHistoryStore = &RetryLayerChannelMemberHistoryStore{ChannelMemberHistoryStore: childStore.ChannelMemberHistory(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &RetryLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CommandStore = &RetryLayerCommandStore{CommandStore: childStore.Command(), Root: &newStore}
	newStore.CommandWebhookStore = &RetryLayerCommandWebhookStore{CommandWebhookStore: childStore.CommandWebhook(), Root: &newStore}
	newStore.ComplianceStore = &RetryLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.EmojiStore = &RetryLayerEmojiStore{EmojiStore: childStore.Emoji(), Root: &newStore}
	newStore.FileInfoStore = &RetryLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.GroupStore = &RetryLayerGroupStore{GroupStore: childStore.Group(), Root: &newStore}
	newStore.JobStore = &RetryLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.LicenseStore = &RetryLayerLicenseStore{LicenseStore: childStore.License(), Root: &newStore}
	newStore.LinkMetadataStore = &RetryLayerLinkMetadataStore{LinkMetadataStore: childStore.LinkMetadata(), Root: &newStore}
	newStore.OAuthStore = &RetryLayerOAuthStore{OAuthStore: childStore.OAuth(), Root: &newStore}
	newStore.PluginStore = &RetryLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PostStore = &RetryLayerPostStore{PostStore: childStore.Post(), Root: &newStore}
	newStore.PreferenceStore = &RetryLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ReactionStore = &RetryLayerReactionStore{ReactionStore: childStore.Reaction(), Root: &newStore}
	newStore.RoleStore = &RetryLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SchemeStore = &RetryLayerSchemeStore{SchemeStore: childStore.Scheme(), Root: &newStore}
	newStore.SessionStore = &RetryLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.StatusStore = &RetryLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.SystemStore = &RetryLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TeamStore = &RetryLayerTeamStore{TeamStore: childStore.Team(), Root: &newStore}
	newStore.TermsOfServiceStore = &RetryLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.TokenStore = &RetryLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.UserStore = &RetryLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &RetryLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserTermsOfServiceStore = &RetryLayerUserTermsOfServiceStore{UserTermsOfServiceStore: childStore.UserTermsOfService(), Root: &newStore}
	newStore.WebhookStore = &RetryLayerWebhookStore{WebhookStore: childStore.Webhook(), Root: &newStore}
	return &newStore
}
