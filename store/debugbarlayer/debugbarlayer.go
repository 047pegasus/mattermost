// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

// Code generated by "make store-layers"
// DO NOT EDIT

package debugbarlayer

import (
	"context"
	"time"
	//"fmt"

	"github.com/mattermost/mattermost-server/v6/app/debugbar"
	"github.com/mattermost/mattermost-server/v6/model"
	"github.com/mattermost/mattermost-server/v6/store"
)

type DebugBarLayer struct {
	store.Store
	debugBar                  *debugbar.DebugBar
	eventPublish              func(event *model.WebSocketEvent)
	AuditStore                store.AuditStore
	BotStore                  store.BotStore
	ChannelStore              store.ChannelStore
	ChannelMemberHistoryStore store.ChannelMemberHistoryStore
	ClusterDiscoveryStore     store.ClusterDiscoveryStore
	CommandStore              store.CommandStore
	CommandWebhookStore       store.CommandWebhookStore
	ComplianceStore           store.ComplianceStore
	DraftStore                store.DraftStore
	EmojiStore                store.EmojiStore
	FileInfoStore             store.FileInfoStore
	GroupStore                store.GroupStore
	JobStore                  store.JobStore
	LicenseStore              store.LicenseStore
	LinkMetadataStore         store.LinkMetadataStore
	NotifyAdminStore          store.NotifyAdminStore
	OAuthStore                store.OAuthStore
	PluginStore               store.PluginStore
	PostStore                 store.PostStore
	PostAcknowledgementStore  store.PostAcknowledgementStore
	PostPriorityStore         store.PostPriorityStore
	PreferenceStore           store.PreferenceStore
	ProductNoticesStore       store.ProductNoticesStore
	ReactionStore             store.ReactionStore
	RemoteClusterStore        store.RemoteClusterStore
	RetentionPolicyStore      store.RetentionPolicyStore
	RoleStore                 store.RoleStore
	SchemeStore               store.SchemeStore
	SessionStore              store.SessionStore
	SharedChannelStore        store.SharedChannelStore
	StatusStore               store.StatusStore
	SystemStore               store.SystemStore
	TeamStore                 store.TeamStore
	TermsOfServiceStore       store.TermsOfServiceStore
	ThreadStore               store.ThreadStore
	TokenStore                store.TokenStore
	TrueUpReviewStore         store.TrueUpReviewStore
	UploadSessionStore        store.UploadSessionStore
	UserStore                 store.UserStore
	UserAccessTokenStore      store.UserAccessTokenStore
	UserTermsOfServiceStore   store.UserTermsOfServiceStore
	WebhookStore              store.WebhookStore
}

func (s *DebugBarLayer) Audit() store.AuditStore {
	return s.AuditStore
}

func (s *DebugBarLayer) Bot() store.BotStore {
	return s.BotStore
}

func (s *DebugBarLayer) Channel() store.ChannelStore {
	return s.ChannelStore
}

func (s *DebugBarLayer) ChannelMemberHistory() store.ChannelMemberHistoryStore {
	return s.ChannelMemberHistoryStore
}

func (s *DebugBarLayer) ClusterDiscovery() store.ClusterDiscoveryStore {
	return s.ClusterDiscoveryStore
}

func (s *DebugBarLayer) Command() store.CommandStore {
	return s.CommandStore
}

func (s *DebugBarLayer) CommandWebhook() store.CommandWebhookStore {
	return s.CommandWebhookStore
}

func (s *DebugBarLayer) Compliance() store.ComplianceStore {
	return s.ComplianceStore
}

func (s *DebugBarLayer) Draft() store.DraftStore {
	return s.DraftStore
}

func (s *DebugBarLayer) Emoji() store.EmojiStore {
	return s.EmojiStore
}

func (s *DebugBarLayer) FileInfo() store.FileInfoStore {
	return s.FileInfoStore
}

func (s *DebugBarLayer) Group() store.GroupStore {
	return s.GroupStore
}

func (s *DebugBarLayer) Job() store.JobStore {
	return s.JobStore
}

func (s *DebugBarLayer) License() store.LicenseStore {
	return s.LicenseStore
}

func (s *DebugBarLayer) LinkMetadata() store.LinkMetadataStore {
	return s.LinkMetadataStore
}

func (s *DebugBarLayer) NotifyAdmin() store.NotifyAdminStore {
	return s.NotifyAdminStore
}

func (s *DebugBarLayer) OAuth() store.OAuthStore {
	return s.OAuthStore
}

func (s *DebugBarLayer) Plugin() store.PluginStore {
	return s.PluginStore
}

func (s *DebugBarLayer) Post() store.PostStore {
	return s.PostStore
}

func (s *DebugBarLayer) PostAcknowledgement() store.PostAcknowledgementStore {
	return s.PostAcknowledgementStore
}

func (s *DebugBarLayer) PostPriority() store.PostPriorityStore {
	return s.PostPriorityStore
}

func (s *DebugBarLayer) Preference() store.PreferenceStore {
	return s.PreferenceStore
}

func (s *DebugBarLayer) ProductNotices() store.ProductNoticesStore {
	return s.ProductNoticesStore
}

func (s *DebugBarLayer) Reaction() store.ReactionStore {
	return s.ReactionStore
}

func (s *DebugBarLayer) RemoteCluster() store.RemoteClusterStore {
	return s.RemoteClusterStore
}

func (s *DebugBarLayer) RetentionPolicy() store.RetentionPolicyStore {
	return s.RetentionPolicyStore
}

func (s *DebugBarLayer) Role() store.RoleStore {
	return s.RoleStore
}

func (s *DebugBarLayer) Scheme() store.SchemeStore {
	return s.SchemeStore
}

func (s *DebugBarLayer) Session() store.SessionStore {
	return s.SessionStore
}

func (s *DebugBarLayer) SharedChannel() store.SharedChannelStore {
	return s.SharedChannelStore
}

func (s *DebugBarLayer) Status() store.StatusStore {
	return s.StatusStore
}

func (s *DebugBarLayer) System() store.SystemStore {
	return s.SystemStore
}

func (s *DebugBarLayer) Team() store.TeamStore {
	return s.TeamStore
}

func (s *DebugBarLayer) TermsOfService() store.TermsOfServiceStore {
	return s.TermsOfServiceStore
}

func (s *DebugBarLayer) Thread() store.ThreadStore {
	return s.ThreadStore
}

func (s *DebugBarLayer) Token() store.TokenStore {
	return s.TokenStore
}

func (s *DebugBarLayer) TrueUpReview() store.TrueUpReviewStore {
	return s.TrueUpReviewStore
}

func (s *DebugBarLayer) UploadSession() store.UploadSessionStore {
	return s.UploadSessionStore
}

func (s *DebugBarLayer) User() store.UserStore {
	return s.UserStore
}

func (s *DebugBarLayer) UserAccessToken() store.UserAccessTokenStore {
	return s.UserAccessTokenStore
}

func (s *DebugBarLayer) UserTermsOfService() store.UserTermsOfServiceStore {
	return s.UserTermsOfServiceStore
}

func (s *DebugBarLayer) Webhook() store.WebhookStore {
	return s.WebhookStore
}

type DebugBarLayerAuditStore struct {
	store.AuditStore
	Root *DebugBarLayer
}

type DebugBarLayerBotStore struct {
	store.BotStore
	Root *DebugBarLayer
}

type DebugBarLayerChannelStore struct {
	store.ChannelStore
	Root *DebugBarLayer
}

type DebugBarLayerChannelMemberHistoryStore struct {
	store.ChannelMemberHistoryStore
	Root *DebugBarLayer
}

type DebugBarLayerClusterDiscoveryStore struct {
	store.ClusterDiscoveryStore
	Root *DebugBarLayer
}

type DebugBarLayerCommandStore struct {
	store.CommandStore
	Root *DebugBarLayer
}

type DebugBarLayerCommandWebhookStore struct {
	store.CommandWebhookStore
	Root *DebugBarLayer
}

type DebugBarLayerComplianceStore struct {
	store.ComplianceStore
	Root *DebugBarLayer
}

type DebugBarLayerDraftStore struct {
	store.DraftStore
	Root *DebugBarLayer
}

type DebugBarLayerEmojiStore struct {
	store.EmojiStore
	Root *DebugBarLayer
}

type DebugBarLayerFileInfoStore struct {
	store.FileInfoStore
	Root *DebugBarLayer
}

type DebugBarLayerGroupStore struct {
	store.GroupStore
	Root *DebugBarLayer
}

type DebugBarLayerJobStore struct {
	store.JobStore
	Root *DebugBarLayer
}

type DebugBarLayerLicenseStore struct {
	store.LicenseStore
	Root *DebugBarLayer
}

type DebugBarLayerLinkMetadataStore struct {
	store.LinkMetadataStore
	Root *DebugBarLayer
}

type DebugBarLayerNotifyAdminStore struct {
	store.NotifyAdminStore
	Root *DebugBarLayer
}

type DebugBarLayerOAuthStore struct {
	store.OAuthStore
	Root *DebugBarLayer
}

type DebugBarLayerPluginStore struct {
	store.PluginStore
	Root *DebugBarLayer
}

type DebugBarLayerPostStore struct {
	store.PostStore
	Root *DebugBarLayer
}

type DebugBarLayerPostAcknowledgementStore struct {
	store.PostAcknowledgementStore
	Root *DebugBarLayer
}

type DebugBarLayerPostPriorityStore struct {
	store.PostPriorityStore
	Root *DebugBarLayer
}

type DebugBarLayerPreferenceStore struct {
	store.PreferenceStore
	Root *DebugBarLayer
}

type DebugBarLayerProductNoticesStore struct {
	store.ProductNoticesStore
	Root *DebugBarLayer
}

type DebugBarLayerReactionStore struct {
	store.ReactionStore
	Root *DebugBarLayer
}

type DebugBarLayerRemoteClusterStore struct {
	store.RemoteClusterStore
	Root *DebugBarLayer
}

type DebugBarLayerRetentionPolicyStore struct {
	store.RetentionPolicyStore
	Root *DebugBarLayer
}

type DebugBarLayerRoleStore struct {
	store.RoleStore
	Root *DebugBarLayer
}

type DebugBarLayerSchemeStore struct {
	store.SchemeStore
	Root *DebugBarLayer
}

type DebugBarLayerSessionStore struct {
	store.SessionStore
	Root *DebugBarLayer
}

type DebugBarLayerSharedChannelStore struct {
	store.SharedChannelStore
	Root *DebugBarLayer
}

type DebugBarLayerStatusStore struct {
	store.StatusStore
	Root *DebugBarLayer
}

type DebugBarLayerSystemStore struct {
	store.SystemStore
	Root *DebugBarLayer
}

type DebugBarLayerTeamStore struct {
	store.TeamStore
	Root *DebugBarLayer
}

type DebugBarLayerTermsOfServiceStore struct {
	store.TermsOfServiceStore
	Root *DebugBarLayer
}

type DebugBarLayerThreadStore struct {
	store.ThreadStore
	Root *DebugBarLayer
}

type DebugBarLayerTokenStore struct {
	store.TokenStore
	Root *DebugBarLayer
}

type DebugBarLayerTrueUpReviewStore struct {
	store.TrueUpReviewStore
	Root *DebugBarLayer
}

type DebugBarLayerUploadSessionStore struct {
	store.UploadSessionStore
	Root *DebugBarLayer
}

type DebugBarLayerUserStore struct {
	store.UserStore
	Root *DebugBarLayer
}

type DebugBarLayerUserAccessTokenStore struct {
	store.UserAccessTokenStore
	Root *DebugBarLayer
}

type DebugBarLayerUserTermsOfServiceStore struct {
	store.UserTermsOfServiceStore
	Root *DebugBarLayer
}

type DebugBarLayerWebhookStore struct {
	store.WebhookStore
	Root *DebugBarLayer
}

func (s *DebugBarLayerAuditStore) Get(user_id string, offset int, limit int) (model.Audits, error) {
	start := time.Now()

	result, err := s.AuditStore.Get(user_id, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{user_id, offset, limit}))
	s.Root.debugBar.SendStoreCall("AuditStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerAuditStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.AuditStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("AuditStore.PermanentDeleteByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerAuditStore) Save(audit *model.Audit) error {
	start := time.Now()

	err := s.AuditStore.Save(audit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{audit}))
	s.Root.debugBar.SendStoreCall("AuditStore.Save", success, elapsed)
	return err
}

func (s *DebugBarLayerBotStore) Get(userID string, includeDeleted bool) (*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.Get(userID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, includeDeleted}))
	s.Root.debugBar.SendStoreCall("BotStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerBotStore) GetAll(options *model.BotGetOptions) ([]*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.GetAll(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("BotStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerBotStore) PermanentDelete(userID string) error {
	start := time.Now()

	err := s.BotStore.PermanentDelete(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("BotStore.PermanentDelete", success, elapsed)
	return err
}

func (s *DebugBarLayerBotStore) Save(bot *model.Bot) (*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.Save(bot)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{bot}))
	s.Root.debugBar.SendStoreCall("BotStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerBotStore) Update(bot *model.Bot) (*model.Bot, error) {
	start := time.Now()

	result, err := s.BotStore.Update(bot)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{bot}))
	s.Root.debugBar.SendStoreCall("BotStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) AnalyticsDeletedTypeCount(teamID string, channelType model.ChannelType) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.AnalyticsDeletedTypeCount(teamID, channelType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, channelType}))
	s.Root.debugBar.SendStoreCall("ChannelStore.AnalyticsDeletedTypeCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) AnalyticsTypeCount(teamID string, channelType model.ChannelType) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.AnalyticsTypeCount(teamID, channelType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, channelType}))
	s.Root.debugBar.SendStoreCall("ChannelStore.AnalyticsTypeCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) Autocomplete(userID string, term string, includeDeleted bool, isGuest bool) (model.ChannelListWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.Autocomplete(userID, term, includeDeleted, isGuest)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, term, includeDeleted, isGuest}))
	s.Root.debugBar.SendStoreCall("ChannelStore.Autocomplete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) AutocompleteInTeam(teamID string, userID string, term string, includeDeleted bool, isGuest bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.AutocompleteInTeam(teamID, userID, term, includeDeleted, isGuest)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, term, includeDeleted, isGuest}))
	s.Root.debugBar.SendStoreCall("ChannelStore.AutocompleteInTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) AutocompleteInTeamForSearch(teamID string, userID string, term string, includeDeleted bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.AutocompleteInTeamForSearch(teamID, userID, term, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, term, includeDeleted}))
	s.Root.debugBar.SendStoreCall("ChannelStore.AutocompleteInTeamForSearch", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) ClearAllCustomRoleAssignments() error {
	start := time.Now()

	err := s.ChannelStore.ClearAllCustomRoleAssignments()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("ChannelStore.ClearAllCustomRoleAssignments", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) ClearCaches() {
	start := time.Now()

	s.ChannelStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("ChannelStore.ClearCaches", success, elapsed)

}

func (s *DebugBarLayerChannelStore) ClearMembersForUserCache() {
	start := time.Now()

	s.ChannelStore.ClearMembersForUserCache()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("ChannelStore.ClearMembersForUserCache", success, elapsed)

}

func (s *DebugBarLayerChannelStore) ClearSidebarOnTeamLeave(userID string, teamID string) error {
	start := time.Now()

	err := s.ChannelStore.ClearSidebarOnTeamLeave(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.ClearSidebarOnTeamLeave", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) CountPostsAfter(channelID string, timestamp int64, userID string) (int, int, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelStore.CountPostsAfter(channelID, timestamp, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.CountPostsAfter", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerChannelStore) CountUrgentPostsAfter(channelID string, timestamp int64, userID string) (int, error) {
	start := time.Now()

	result, err := s.ChannelStore.CountUrgentPostsAfter(channelID, timestamp, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.CountUrgentPostsAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) CreateDirectChannel(userID *model.User, otherUserID *model.User, channelOptions ...model.ChannelOption) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.CreateDirectChannel(userID, otherUserID, channelOptions...)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, otherUserID, channelOptions...}))
	s.Root.debugBar.SendStoreCall("ChannelStore.CreateDirectChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) CreateInitialSidebarCategories(userID string, opts *store.SidebarCategorySearchOpts) (*model.OrderedSidebarCategories, error) {
	start := time.Now()

	result, err := s.ChannelStore.CreateInitialSidebarCategories(userID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, opts}))
	s.Root.debugBar.SendStoreCall("ChannelStore.CreateInitialSidebarCategories", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) CreateSidebarCategory(userID string, teamID string, newCategory *model.SidebarCategoryWithChannels) (*model.SidebarCategoryWithChannels, error) {
	start := time.Now()

	result, err := s.ChannelStore.CreateSidebarCategory(userID, teamID, newCategory)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, newCategory}))
	s.Root.debugBar.SendStoreCall("ChannelStore.CreateSidebarCategory", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) Delete(channelID string, timestamp int64) error {
	start := time.Now()

	err := s.ChannelStore.Delete(channelID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp}))
	s.Root.debugBar.SendStoreCall("ChannelStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) DeleteSidebarCategory(categoryID string) error {
	start := time.Now()

	err := s.ChannelStore.DeleteSidebarCategory(categoryID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{categoryID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.DeleteSidebarCategory", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) DeleteSidebarChannelsByPreferences(preferences model.Preferences) error {
	start := time.Now()

	err := s.ChannelStore.DeleteSidebarChannelsByPreferences(preferences)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{preferences}))
	s.Root.debugBar.SendStoreCall("ChannelStore.DeleteSidebarChannelsByPreferences", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) Get(id string, allowFromCache bool) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.Get(id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAll(teamID string) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAll(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAllChannelMembersById(id string) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelMembersById(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAllChannelMembersById", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAllChannelMembersForUser(userID string, allowFromCache bool, includeDeleted bool) (map[string]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelMembersForUser(userID, allowFromCache, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, allowFromCache, includeDeleted}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAllChannelMembersForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAllChannelMembersNotifyPropsForChannel(channelID string, allowFromCache bool) (map[string]model.StringMap, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelMembersNotifyPropsForChannel(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAllChannelMembersNotifyPropsForChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAllChannels(page int, perPage int, opts store.ChannelSearchOpts) (model.ChannelListWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannels(page, perPage, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{page, perPage, opts}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAllChannels", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAllChannelsCount(opts store.ChannelSearchOpts) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelsCount(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAllChannelsCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAllChannelsForExportAfter(limit int, afterID string) ([]*model.ChannelForExport, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllChannelsForExportAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit, afterID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAllChannelsForExportAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetAllDirectChannelsForExportAfter(limit int, afterID string) ([]*model.DirectChannelForExport, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetAllDirectChannelsForExportAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit, afterID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetAllDirectChannelsForExportAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetByName(team_id string, name string, allowFromCache bool) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetByName(team_id, name, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{team_id, name, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetByNameIncludeDeleted(team_id string, name string, allowFromCache bool) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetByNameIncludeDeleted(team_id, name, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{team_id, name, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetByNameIncludeDeleted", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetByNames(team_id string, names []string, allowFromCache bool) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetByNames(team_id, names, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{team_id, names, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetByNames", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelCounts(teamID string, userID string) (*model.ChannelCounts, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelCounts(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelCounts", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelMembersForExport(userID string, teamID string) ([]*model.ChannelMemberForExport, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelMembersForExport(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelMembersForExport", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelMembersTimezones(channelID string) ([]model.StringMap, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelMembersTimezones(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelMembersTimezones", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelUnread(channelID string, userID string) (*model.ChannelUnread, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelUnread(channelID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelUnread", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannels(teamID string, userID string, opts *model.ChannelSearchOpts) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannels(teamID, userID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, opts}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannels", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelsBatchForIndexing(startTime int64, startChannelID string, limit int) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsBatchForIndexing(startTime, startChannelID, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{startTime, startChannelID, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelsBatchForIndexing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelsByIds(channelIds []string, includeDeleted bool) ([]*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsByIds(channelIds, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelIds, includeDeleted}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelsByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelsByScheme(schemeID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsByScheme(schemeID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{schemeID, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelsByScheme", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelsByUser(userID string, includeDeleted bool, lastDeleteAt int, pageSize int, fromChannelID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsByUser(userID, includeDeleted, lastDeleteAt, pageSize, fromChannelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, includeDeleted, lastDeleteAt, pageSize, fromChannelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelsByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelsWithCursor(teamId string, userId string, opts *model.ChannelSearchOpts, afterChannelID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsWithCursor(teamId, userId, opts, afterChannelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamId, userId, opts, afterChannelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelsWithCursor", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetChannelsWithTeamDataByIds(channelIds []string, includeDeleted bool) ([]*model.ChannelWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetChannelsWithTeamDataByIds(channelIds, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelIds, includeDeleted}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetChannelsWithTeamDataByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetDeleted(team_id string, offset int, limit int, userID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetDeleted(team_id, offset, limit, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{team_id, offset, limit, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetDeleted", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetDeletedByName(team_id string, name string) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetDeletedByName(team_id, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{team_id, name}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetDeletedByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetFileCount(channelID string) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetFileCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetFileCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetForPost(postID string) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetGuestCount(channelID string, allowFromCache bool) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetGuestCount(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetGuestCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMany(ids []string, allowFromCache bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMany(ids, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ids, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMany", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMember(ctx context.Context, channelID string, userID string) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMember(ctx, channelID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, channelID, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMemberCount(channelID string, allowFromCache bool) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMemberCount(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMemberCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMemberCountFromCache(channelID string) int64 {
	start := time.Now()

	result := s.ChannelStore.GetMemberCountFromCache(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMemberCountFromCache", success, elapsed)
	return result
}

func (s *DebugBarLayerChannelStore) GetMemberCountsByGroup(ctx context.Context, channelID string, includeTimezones bool) ([]*model.ChannelMemberCountByGroup, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMemberCountsByGroup(ctx, channelID, includeTimezones)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, channelID, includeTimezones}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMemberCountsByGroup", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMemberForPost(postID string, userID string) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMemberForPost(postID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMemberForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMembers(channelID string, offset int, limit int) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembers(channelID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMembersByChannelIds(channelIds []string, userID string) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersByChannelIds(channelIds, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelIds, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMembersByChannelIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMembersByIds(channelID string, userIds []string) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersByIds(channelID, userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userIds}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMembersByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMembersForUser(teamID string, userID string) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersForUser(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMembersForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMembersForUserWithCursor(userID string, teamID string, opts *store.ChannelMemberGraphQLSearchOpts) (model.ChannelMembers, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersForUserWithCursor(userID, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, opts}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMembersForUserWithCursor", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMembersForUserWithPagination(userID string, page int, perPage int) (model.ChannelMembersWithTeamData, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersForUserWithPagination(userID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, page, perPage}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMembersForUserWithPagination", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMembersInfoByChannelIds(channelIDs []string) (map[string][]*model.User, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMembersInfoByChannelIds(channelIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelIDs}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMembersInfoByChannelIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetMoreChannels(teamID string, userID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetMoreChannels(teamID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetMoreChannels", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetPinnedPostCount(channelID string, allowFromCache bool) (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPinnedPostCount(channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetPinnedPostCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetPinnedPosts(channelID string) (*model.PostList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPinnedPosts(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetPinnedPosts", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetPrivateChannelsForTeam(teamID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPrivateChannelsForTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetPrivateChannelsForTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetPublicChannelsByIdsForTeam(teamID string, channelIds []string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPublicChannelsByIdsForTeam(teamID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, channelIds}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetPublicChannelsByIdsForTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetPublicChannelsForTeam(teamID string, offset int, limit int) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetPublicChannelsForTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetPublicChannelsForTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetSidebarCategories(userID string, opts *store.SidebarCategorySearchOpts) (*model.OrderedSidebarCategories, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategories(userID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, opts}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetSidebarCategories", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetSidebarCategoriesForTeamForUser(userID string, teamID string) (*model.OrderedSidebarCategories, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategoriesForTeamForUser(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetSidebarCategoriesForTeamForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetSidebarCategory(categoryID string) (*model.SidebarCategoryWithChannels, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategory(categoryID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{categoryID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetSidebarCategory", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetSidebarCategoryOrder(userID string, teamID string) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetSidebarCategoryOrder(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetSidebarCategoryOrder", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetTeamChannels(teamID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTeamChannels(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetTeamChannels", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetTeamForChannel(channelID string) (*model.Team, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTeamForChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetTeamForChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetTeamMembersForChannel(channelID string) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTeamMembersForChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetTeamMembersForChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetTopChannelsForTeamSince(teamID string, userID string, since int64, offset int, limit int) (*model.TopChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTopChannelsForTeamSince(teamID, userID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetTopChannelsForTeamSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetTopChannelsForUserSince(userID string, teamID string, since int64, offset int, limit int) (*model.TopChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTopChannelsForUserSince(userID, teamID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetTopChannelsForUserSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetTopInactiveChannelsForTeamSince(teamID string, userID string, since int64, offset int, limit int) (*model.TopInactiveChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTopInactiveChannelsForTeamSince(teamID, userID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetTopInactiveChannelsForTeamSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GetTopInactiveChannelsForUserSince(teamID string, userID string, since int64, offset int, limit int) (*model.TopInactiveChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.GetTopInactiveChannelsForUserSince(teamID, userID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GetTopInactiveChannelsForUserSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) GroupSyncedChannelCount() (int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.GroupSyncedChannelCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("ChannelStore.GroupSyncedChannelCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) IncrementMentionCount(channelID string, userIDs []string, isRoot bool, isUrgent bool) error {
	start := time.Now()

	err := s.ChannelStore.IncrementMentionCount(channelID, userIDs, isRoot, isUrgent)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userIDs, isRoot, isUrgent}))
	s.Root.debugBar.SendStoreCall("ChannelStore.IncrementMentionCount", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) InvalidateAllChannelMembersForUser(userID string) {
	start := time.Now()

	s.ChannelStore.InvalidateAllChannelMembersForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.InvalidateAllChannelMembersForUser", success, elapsed)

}

func (s *DebugBarLayerChannelStore) InvalidateCacheForChannelMembersNotifyProps(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidateCacheForChannelMembersNotifyProps(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.InvalidateCacheForChannelMembersNotifyProps", success, elapsed)

}

func (s *DebugBarLayerChannelStore) InvalidateChannel(id string) {
	start := time.Now()

	s.ChannelStore.InvalidateChannel(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("ChannelStore.InvalidateChannel", success, elapsed)

}

func (s *DebugBarLayerChannelStore) InvalidateChannelByName(teamID string, name string) {
	start := time.Now()

	s.ChannelStore.InvalidateChannelByName(teamID, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, name}))
	s.Root.debugBar.SendStoreCall("ChannelStore.InvalidateChannelByName", success, elapsed)

}

func (s *DebugBarLayerChannelStore) InvalidateGuestCount(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidateGuestCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.InvalidateGuestCount", success, elapsed)

}

func (s *DebugBarLayerChannelStore) InvalidateMemberCount(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidateMemberCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.InvalidateMemberCount", success, elapsed)

}

func (s *DebugBarLayerChannelStore) InvalidatePinnedPostCount(channelID string) {
	start := time.Now()

	s.ChannelStore.InvalidatePinnedPostCount(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.InvalidatePinnedPostCount", success, elapsed)

}

func (s *DebugBarLayerChannelStore) IsUserInChannelUseCache(userID string, channelID string) bool {
	start := time.Now()

	result := s.ChannelStore.IsUserInChannelUseCache(userID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.IsUserInChannelUseCache", success, elapsed)
	return result
}

func (s *DebugBarLayerChannelStore) MigrateChannelMembers(fromChannelID string, fromUserID string) (map[string]string, error) {
	start := time.Now()

	result, err := s.ChannelStore.MigrateChannelMembers(fromChannelID, fromUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{fromChannelID, fromUserID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.MigrateChannelMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) PermanentDelete(channelID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDelete(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.PermanentDelete", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) PermanentDeleteByTeam(teamID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDeleteByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.PermanentDeleteByTeam", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) PermanentDeleteMembersByChannel(channelID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDeleteMembersByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.PermanentDeleteMembersByChannel", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) PermanentDeleteMembersByUser(userID string) error {
	start := time.Now()

	err := s.ChannelStore.PermanentDeleteMembersByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.PermanentDeleteMembersByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) PostCountsByDuration(channelIDs []string, sinceUnixMillis int64, userID *string, duration model.PostCountGrouping, groupingLocation *time.Location) ([]*model.DurationPostCount, error) {
	start := time.Now()

	result, err := s.ChannelStore.PostCountsByDuration(channelIDs, sinceUnixMillis, userID, duration, groupingLocation)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelIDs, sinceUnixMillis, userID, duration, groupingLocation}))
	s.Root.debugBar.SendStoreCall("ChannelStore.PostCountsByDuration", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) RemoveAllDeactivatedMembers(channelID string) error {
	start := time.Now()

	err := s.ChannelStore.RemoveAllDeactivatedMembers(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.RemoveAllDeactivatedMembers", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) RemoveMember(channelID string, userID string) error {
	start := time.Now()

	err := s.ChannelStore.RemoveMember(channelID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.RemoveMember", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) RemoveMembers(channelID string, userIds []string) error {
	start := time.Now()

	err := s.ChannelStore.RemoveMembers(channelID, userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userIds}))
	s.Root.debugBar.SendStoreCall("ChannelStore.RemoveMembers", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) ResetAllChannelSchemes() error {
	start := time.Now()

	err := s.ChannelStore.ResetAllChannelSchemes()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("ChannelStore.ResetAllChannelSchemes", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) Restore(channelID string, timestamp int64) error {
	start := time.Now()

	err := s.ChannelStore.Restore(channelID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp}))
	s.Root.debugBar.SendStoreCall("ChannelStore.Restore", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) Save(channel *model.Channel, maxChannelsPerTeam int64) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.Save(channel, maxChannelsPerTeam)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channel, maxChannelsPerTeam}))
	s.Root.debugBar.SendStoreCall("ChannelStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SaveDirectChannel(channel *model.Channel, member1 *model.ChannelMember, member2 *model.ChannelMember) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.SaveDirectChannel(channel, member1, member2)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channel, member1, member2}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SaveDirectChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SaveMember(member *model.ChannelMember) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.SaveMember(member)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{member}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SaveMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SaveMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.SaveMultipleMembers(members)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{members}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SaveMultipleMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SearchAllChannels(term string, opts store.ChannelSearchOpts) (model.ChannelListWithTeamData, int64, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelStore.SearchAllChannels(term, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{term, opts}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SearchAllChannels", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerChannelStore) SearchArchivedInTeam(teamID string, term string, userID string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchArchivedInTeam(teamID, term, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, term, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SearchArchivedInTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SearchForUserInTeam(userID string, teamID string, term string, includeDeleted bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchForUserInTeam(userID, teamID, term, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, term, includeDeleted}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SearchForUserInTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SearchGroupChannels(userID string, term string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchGroupChannels(userID, term)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, term}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SearchGroupChannels", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SearchInTeam(teamID string, term string, includeDeleted bool) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchInTeam(teamID, term, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, term, includeDeleted}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SearchInTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SearchMore(userID string, teamID string, term string) (model.ChannelList, error) {
	start := time.Now()

	result, err := s.ChannelStore.SearchMore(userID, teamID, term)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, term}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SearchMore", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) SetDeleteAt(channelID string, deleteAt int64, updateAt int64) error {
	start := time.Now()

	err := s.ChannelStore.SetDeleteAt(channelID, deleteAt, updateAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, deleteAt, updateAt}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SetDeleteAt", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) SetShared(channelId string, shared bool) error {
	start := time.Now()

	err := s.ChannelStore.SetShared(channelId, shared)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelId, shared}))
	s.Root.debugBar.SendStoreCall("ChannelStore.SetShared", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) Update(channel *model.Channel) (*model.Channel, error) {
	start := time.Now()

	result, err := s.ChannelStore.Update(channel)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channel}))
	s.Root.debugBar.SendStoreCall("ChannelStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) UpdateLastViewedAt(channelIds []string, userID string) (map[string]int64, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateLastViewedAt(channelIds, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelIds, userID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateLastViewedAt", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) UpdateLastViewedAtPost(unreadPost *model.Post, userID string, mentionCount int, mentionCountRoot int, urgentMentionCount int, setUnreadCountRoot bool) (*model.ChannelUnreadAt, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateLastViewedAtPost(unreadPost, userID, mentionCount, mentionCountRoot, urgentMentionCount, setUnreadCountRoot)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{unreadPost, userID, mentionCount, mentionCountRoot, urgentMentionCount, setUnreadCountRoot}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateLastViewedAtPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) UpdateMember(member *model.ChannelMember) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateMember(member)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{member}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) UpdateMemberNotifyProps(channelID string, userID string, props map[string]string) (*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateMemberNotifyProps(channelID, userID, props)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userID, props}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateMemberNotifyProps", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) UpdateMembersRole(channelID string, userIDs []string) error {
	start := time.Now()

	err := s.ChannelStore.UpdateMembersRole(channelID, userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userIDs}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateMembersRole", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) UpdateMultipleMembers(members []*model.ChannelMember) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.ChannelStore.UpdateMultipleMembers(members)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{members}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateMultipleMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelStore) UpdateSidebarCategories(userID string, teamID string, categories []*model.SidebarCategoryWithChannels) ([]*model.SidebarCategoryWithChannels, []*model.SidebarCategoryWithChannels, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelStore.UpdateSidebarCategories(userID, teamID, categories)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, categories}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateSidebarCategories", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerChannelStore) UpdateSidebarCategoryOrder(userID string, teamID string, categoryOrder []string) error {
	start := time.Now()

	err := s.ChannelStore.UpdateSidebarCategoryOrder(userID, teamID, categoryOrder)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, categoryOrder}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateSidebarCategoryOrder", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) UpdateSidebarChannelCategoryOnMove(channel *model.Channel, newTeamID string) error {
	start := time.Now()

	err := s.ChannelStore.UpdateSidebarChannelCategoryOnMove(channel, newTeamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channel, newTeamID}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateSidebarChannelCategoryOnMove", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) UpdateSidebarChannelsByPreferences(preferences model.Preferences) error {
	start := time.Now()

	err := s.ChannelStore.UpdateSidebarChannelsByPreferences(preferences)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{preferences}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UpdateSidebarChannelsByPreferences", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelStore) UserBelongsToChannels(userID string, channelIds []string) (bool, error) {
	start := time.Now()

	result, err := s.ChannelStore.UserBelongsToChannels(userID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelIds}))
	s.Root.debugBar.SendStoreCall("ChannelStore.UserBelongsToChannels", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelMemberHistoryStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit}))
	s.Root.debugBar.SendStoreCall("ChannelMemberHistoryStore.DeleteOrphanedRows", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelMemberHistoryStore) GetChannelsLeftSince(userID string, since int64) ([]string, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.GetChannelsLeftSince(userID, since)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, since}))
	s.Root.debugBar.SendStoreCall("ChannelMemberHistoryStore.GetChannelsLeftSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelMemberHistoryStore) GetUsersInChannelDuring(startTime int64, endTime int64, channelID string) ([]*model.ChannelMemberHistoryResult, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.GetUsersInChannelDuring(startTime, endTime, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{startTime, endTime, channelID}))
	s.Root.debugBar.SendStoreCall("ChannelMemberHistoryStore.GetUsersInChannelDuring", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelMemberHistoryStore) LogJoinEvent(userID string, channelID string, joinTime int64) error {
	start := time.Now()

	err := s.ChannelMemberHistoryStore.LogJoinEvent(userID, channelID, joinTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID, joinTime}))
	s.Root.debugBar.SendStoreCall("ChannelMemberHistoryStore.LogJoinEvent", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelMemberHistoryStore) LogLeaveEvent(userID string, channelID string, leaveTime int64) error {
	start := time.Now()

	err := s.ChannelMemberHistoryStore.LogLeaveEvent(userID, channelID, leaveTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID, leaveTime}))
	s.Root.debugBar.SendStoreCall("ChannelMemberHistoryStore.LogLeaveEvent", success, elapsed)
	return err
}

func (s *DebugBarLayerChannelMemberHistoryStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.ChannelMemberHistoryStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{endTime, limit}))
	s.Root.debugBar.SendStoreCall("ChannelMemberHistoryStore.PermanentDeleteBatch", success, elapsed)
	return result, err
}

func (s *DebugBarLayerChannelMemberHistoryStore) PermanentDeleteBatchForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ChannelMemberHistoryStore.PermanentDeleteBatchForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{now, globalPolicyEndTime, limit, cursor}))
	s.Root.debugBar.SendStoreCall("ChannelMemberHistoryStore.PermanentDeleteBatchForRetentionPolicies", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerClusterDiscoveryStore) Cleanup() error {
	start := time.Now()

	err := s.ClusterDiscoveryStore.Cleanup()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("ClusterDiscoveryStore.Cleanup", success, elapsed)
	return err
}

func (s *DebugBarLayerClusterDiscoveryStore) Delete(discovery *model.ClusterDiscovery) (bool, error) {
	start := time.Now()

	result, err := s.ClusterDiscoveryStore.Delete(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{discovery}))
	s.Root.debugBar.SendStoreCall("ClusterDiscoveryStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerClusterDiscoveryStore) Exists(discovery *model.ClusterDiscovery) (bool, error) {
	start := time.Now()

	result, err := s.ClusterDiscoveryStore.Exists(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{discovery}))
	s.Root.debugBar.SendStoreCall("ClusterDiscoveryStore.Exists", success, elapsed)
	return result, err
}

func (s *DebugBarLayerClusterDiscoveryStore) GetAll(discoveryType string, clusterName string) ([]*model.ClusterDiscovery, error) {
	start := time.Now()

	result, err := s.ClusterDiscoveryStore.GetAll(discoveryType, clusterName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{discoveryType, clusterName}))
	s.Root.debugBar.SendStoreCall("ClusterDiscoveryStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerClusterDiscoveryStore) Save(discovery *model.ClusterDiscovery) error {
	start := time.Now()

	err := s.ClusterDiscoveryStore.Save(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{discovery}))
	s.Root.debugBar.SendStoreCall("ClusterDiscoveryStore.Save", success, elapsed)
	return err
}

func (s *DebugBarLayerClusterDiscoveryStore) SetLastPingAt(discovery *model.ClusterDiscovery) error {
	start := time.Now()

	err := s.ClusterDiscoveryStore.SetLastPingAt(discovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{discovery}))
	s.Root.debugBar.SendStoreCall("ClusterDiscoveryStore.SetLastPingAt", success, elapsed)
	return err
}

func (s *DebugBarLayerCommandStore) AnalyticsCommandCount(teamID string) (int64, error) {
	start := time.Now()

	result, err := s.CommandStore.AnalyticsCommandCount(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("CommandStore.AnalyticsCommandCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandStore) Delete(commandID string, timestamp int64) error {
	start := time.Now()

	err := s.CommandStore.Delete(commandID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{commandID, timestamp}))
	s.Root.debugBar.SendStoreCall("CommandStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerCommandStore) Get(id string) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("CommandStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandStore) GetByTeam(teamID string) ([]*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.GetByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("CommandStore.GetByTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandStore) GetByTrigger(teamID string, trigger string) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.GetByTrigger(teamID, trigger)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, trigger}))
	s.Root.debugBar.SendStoreCall("CommandStore.GetByTrigger", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandStore) PermanentDeleteByTeam(teamID string) error {
	start := time.Now()

	err := s.CommandStore.PermanentDeleteByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("CommandStore.PermanentDeleteByTeam", success, elapsed)
	return err
}

func (s *DebugBarLayerCommandStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.CommandStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("CommandStore.PermanentDeleteByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerCommandStore) Save(webhook *model.Command) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.Save(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhook}))
	s.Root.debugBar.SendStoreCall("CommandStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandStore) Update(hook *model.Command) (*model.Command, error) {
	start := time.Now()

	result, err := s.CommandStore.Update(hook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{hook}))
	s.Root.debugBar.SendStoreCall("CommandStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandWebhookStore) Cleanup() {
	start := time.Now()

	s.CommandWebhookStore.Cleanup()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("CommandWebhookStore.Cleanup", success, elapsed)

}

func (s *DebugBarLayerCommandWebhookStore) Get(id string) (*model.CommandWebhook, error) {
	start := time.Now()

	result, err := s.CommandWebhookStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("CommandWebhookStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandWebhookStore) Save(webhook *model.CommandWebhook) (*model.CommandWebhook, error) {
	start := time.Now()

	result, err := s.CommandWebhookStore.Save(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhook}))
	s.Root.debugBar.SendStoreCall("CommandWebhookStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerCommandWebhookStore) TryUse(id string, limit int) error {
	start := time.Now()

	err := s.CommandWebhookStore.TryUse(id, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, limit}))
	s.Root.debugBar.SendStoreCall("CommandWebhookStore.TryUse", success, elapsed)
	return err
}

func (s *DebugBarLayerComplianceStore) ComplianceExport(compliance *model.Compliance, cursor model.ComplianceExportCursor, limit int) ([]*model.CompliancePost, model.ComplianceExportCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ComplianceStore.ComplianceExport(compliance, cursor, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{compliance, cursor, limit}))
	s.Root.debugBar.SendStoreCall("ComplianceStore.ComplianceExport", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerComplianceStore) Get(id string) (*model.Compliance, error) {
	start := time.Now()

	result, err := s.ComplianceStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("ComplianceStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerComplianceStore) GetAll(offset int, limit int) (model.Compliances, error) {
	start := time.Now()

	result, err := s.ComplianceStore.GetAll(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit}))
	s.Root.debugBar.SendStoreCall("ComplianceStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerComplianceStore) MessageExport(ctx context.Context, cursor model.MessageExportCursor, limit int) ([]*model.MessageExport, model.MessageExportCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ComplianceStore.MessageExport(ctx, cursor, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, cursor, limit}))
	s.Root.debugBar.SendStoreCall("ComplianceStore.MessageExport", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerComplianceStore) Save(compliance *model.Compliance) (*model.Compliance, error) {
	start := time.Now()

	result, err := s.ComplianceStore.Save(compliance)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{compliance}))
	s.Root.debugBar.SendStoreCall("ComplianceStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerComplianceStore) Update(compliance *model.Compliance) (*model.Compliance, error) {
	start := time.Now()

	result, err := s.ComplianceStore.Update(compliance)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{compliance}))
	s.Root.debugBar.SendStoreCall("ComplianceStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerDraftStore) Delete(userID string, channelID string, rootID string) error {
	start := time.Now()

	err := s.DraftStore.Delete(userID, channelID, rootID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID, rootID}))
	s.Root.debugBar.SendStoreCall("DraftStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerDraftStore) Get(userID string, channelID string, rootID string, includeDeleted bool) (*model.Draft, error) {
	start := time.Now()

	result, err := s.DraftStore.Get(userID, channelID, rootID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID, rootID, includeDeleted}))
	s.Root.debugBar.SendStoreCall("DraftStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerDraftStore) GetDraftsForUser(userID string, teamID string) ([]*model.Draft, error) {
	start := time.Now()

	result, err := s.DraftStore.GetDraftsForUser(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID}))
	s.Root.debugBar.SendStoreCall("DraftStore.GetDraftsForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerDraftStore) Save(d *model.Draft) (*model.Draft, error) {
	start := time.Now()

	result, err := s.DraftStore.Save(d)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{d}))
	s.Root.debugBar.SendStoreCall("DraftStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerDraftStore) Update(d *model.Draft) (*model.Draft, error) {
	start := time.Now()

	result, err := s.DraftStore.Update(d)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{d}))
	s.Root.debugBar.SendStoreCall("DraftStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerEmojiStore) Delete(emoji *model.Emoji, timestamp int64) error {
	start := time.Now()

	err := s.EmojiStore.Delete(emoji, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{emoji, timestamp}))
	s.Root.debugBar.SendStoreCall("EmojiStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerEmojiStore) Get(ctx context.Context, id string, allowFromCache bool) (*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.Get(ctx, id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, id, allowFromCache}))
	s.Root.debugBar.SendStoreCall("EmojiStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerEmojiStore) GetByName(ctx context.Context, name string, allowFromCache bool) (*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.GetByName(ctx, name, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, name, allowFromCache}))
	s.Root.debugBar.SendStoreCall("EmojiStore.GetByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerEmojiStore) GetList(offset int, limit int, sort string) ([]*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.GetList(offset, limit, sort)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit, sort}))
	s.Root.debugBar.SendStoreCall("EmojiStore.GetList", success, elapsed)
	return result, err
}

func (s *DebugBarLayerEmojiStore) GetMultipleByName(names []string) ([]*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.GetMultipleByName(names)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{names}))
	s.Root.debugBar.SendStoreCall("EmojiStore.GetMultipleByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerEmojiStore) Save(emoji *model.Emoji) (*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.Save(emoji)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{emoji}))
	s.Root.debugBar.SendStoreCall("EmojiStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerEmojiStore) Search(name string, prefixOnly bool, limit int) ([]*model.Emoji, error) {
	start := time.Now()

	result, err := s.EmojiStore.Search(name, prefixOnly, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{name, prefixOnly, limit}))
	s.Root.debugBar.SendStoreCall("EmojiStore.Search", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) AttachToPost(fileID string, postID string, creatorID string) error {
	start := time.Now()

	err := s.FileInfoStore.AttachToPost(fileID, postID, creatorID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{fileID, postID, creatorID}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.AttachToPost", success, elapsed)
	return err
}

func (s *DebugBarLayerFileInfoStore) ClearCaches() {
	start := time.Now()

	s.FileInfoStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.ClearCaches", success, elapsed)

}

func (s *DebugBarLayerFileInfoStore) CountAll() (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.CountAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.CountAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) DeleteForPost(postID string) (string, error) {
	start := time.Now()

	result, err := s.FileInfoStore.DeleteForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.DeleteForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) Get(id string) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetByIds(ids []string) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetByIds(ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ids}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetByPath(path string) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetByPath(path)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{path}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetByPath", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetFilesBatchForIndexing(startTime int64, startFileID string, limit int) ([]*model.FileForIndexing, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetFilesBatchForIndexing(startTime, startFileID, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{startTime, startFileID, limit}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetFilesBatchForIndexing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetForPost(postID string, readFromMaster bool, includeDeleted bool, allowFromCache bool) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetForPost(postID, readFromMaster, includeDeleted, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID, readFromMaster, includeDeleted, allowFromCache}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetForUser(userID string) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetFromMaster(id string) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetFromMaster(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetFromMaster", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetStorageUsage(allowFromCache bool, includeDeleted bool) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetStorageUsage(allowFromCache, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{allowFromCache, includeDeleted}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetStorageUsage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetUptoNSizeFileTime(n int64) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetUptoNSizeFileTime(n)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{n}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetUptoNSizeFileTime", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) GetWithOptions(page int, perPage int, opt *model.GetFileInfosOptions) ([]*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.GetWithOptions(page, perPage, opt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{page, perPage, opt}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.GetWithOptions", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) InvalidateFileInfosForPostCache(postID string, deleted bool) {
	start := time.Now()

	s.FileInfoStore.InvalidateFileInfosForPostCache(postID, deleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID, deleted}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.InvalidateFileInfosForPostCache", success, elapsed)

}

func (s *DebugBarLayerFileInfoStore) PermanentDelete(fileID string) error {
	start := time.Now()

	err := s.FileInfoStore.PermanentDelete(fileID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{fileID}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.PermanentDelete", success, elapsed)
	return err
}

func (s *DebugBarLayerFileInfoStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{endTime, limit}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.PermanentDeleteBatch", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) PermanentDeleteByUser(userID string) (int64, error) {
	start := time.Now()

	result, err := s.FileInfoStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.PermanentDeleteByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) Save(info *model.FileInfo) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Save(info)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{info}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) Search(paramsList []*model.SearchParams, userID string, teamID string, page int, perPage int) (*model.FileInfoList, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Search(paramsList, userID, teamID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{paramsList, userID, teamID, page, perPage}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.Search", success, elapsed)
	return result, err
}

func (s *DebugBarLayerFileInfoStore) SetContent(fileID string, content string) error {
	start := time.Now()

	err := s.FileInfoStore.SetContent(fileID, content)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{fileID, content}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.SetContent", success, elapsed)
	return err
}

func (s *DebugBarLayerFileInfoStore) Upsert(info *model.FileInfo) (*model.FileInfo, error) {
	start := time.Now()

	result, err := s.FileInfoStore.Upsert(info)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{info}))
	s.Root.debugBar.SendStoreCall("FileInfoStore.Upsert", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) AdminRoleGroupsForSyncableMember(userID string, syncableID string, syncableType model.GroupSyncableType) ([]string, error) {
	start := time.Now()

	result, err := s.GroupStore.AdminRoleGroupsForSyncableMember(userID, syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, syncableID, syncableType}))
	s.Root.debugBar.SendStoreCall("GroupStore.AdminRoleGroupsForSyncableMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) ChannelMembersMinusGroupMembers(channelID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, error) {
	start := time.Now()

	result, err := s.GroupStore.ChannelMembersMinusGroupMembers(channelID, groupIDs, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, groupIDs, page, perPage}))
	s.Root.debugBar.SendStoreCall("GroupStore.ChannelMembersMinusGroupMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) ChannelMembersToAdd(since int64, channelID *string, includeRemovedMembers bool) ([]*model.UserChannelIDPair, error) {
	start := time.Now()

	result, err := s.GroupStore.ChannelMembersToAdd(since, channelID, includeRemovedMembers)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{since, channelID, includeRemovedMembers}))
	s.Root.debugBar.SendStoreCall("GroupStore.ChannelMembersToAdd", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) ChannelMembersToRemove(channelID *string) ([]*model.ChannelMember, error) {
	start := time.Now()

	result, err := s.GroupStore.ChannelMembersToRemove(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("GroupStore.ChannelMembersToRemove", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) CountChannelMembersMinusGroupMembers(channelID string, groupIDs []string) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountChannelMembersMinusGroupMembers(channelID, groupIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, groupIDs}))
	s.Root.debugBar.SendStoreCall("GroupStore.CountChannelMembersMinusGroupMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) CountGroupsByChannel(channelID string, opts model.GroupSearchOpts) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountGroupsByChannel(channelID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, opts}))
	s.Root.debugBar.SendStoreCall("GroupStore.CountGroupsByChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) CountGroupsByTeam(teamID string, opts model.GroupSearchOpts) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountGroupsByTeam(teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, opts}))
	s.Root.debugBar.SendStoreCall("GroupStore.CountGroupsByTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) CountTeamMembersMinusGroupMembers(teamID string, groupIDs []string) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.CountTeamMembersMinusGroupMembers(teamID, groupIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, groupIDs}))
	s.Root.debugBar.SendStoreCall("GroupStore.CountTeamMembersMinusGroupMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) Create(group *model.Group) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Create(group)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{group}))
	s.Root.debugBar.SendStoreCall("GroupStore.Create", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) CreateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.CreateGroupSyncable(groupSyncable)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupSyncable}))
	s.Root.debugBar.SendStoreCall("GroupStore.CreateGroupSyncable", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) CreateWithUserIds(group *model.GroupWithUserIds) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.CreateWithUserIds(group)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{group}))
	s.Root.debugBar.SendStoreCall("GroupStore.CreateWithUserIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) Delete(groupID string) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Delete(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID}))
	s.Root.debugBar.SendStoreCall("GroupStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) DeleteGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.DeleteGroupSyncable(groupID, syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, syncableID, syncableType}))
	s.Root.debugBar.SendStoreCall("GroupStore.DeleteGroupSyncable", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) DeleteMember(groupID string, userID string) (*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.DeleteMember(groupID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, userID}))
	s.Root.debugBar.SendStoreCall("GroupStore.DeleteMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) DeleteMembers(groupID string, userIDs []string) ([]*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.DeleteMembers(groupID, userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, userIDs}))
	s.Root.debugBar.SendStoreCall("GroupStore.DeleteMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) DistinctGroupMemberCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.DistinctGroupMemberCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("GroupStore.DistinctGroupMemberCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) DistinctGroupMemberCountForSource(source model.GroupSource) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.DistinctGroupMemberCountForSource(source)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{source}))
	s.Root.debugBar.SendStoreCall("GroupStore.DistinctGroupMemberCountForSource", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) Get(groupID string) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Get(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID}))
	s.Root.debugBar.SendStoreCall("GroupStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetAllBySource(groupSource model.GroupSource) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetAllBySource(groupSource)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupSource}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetAllBySource", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetAllGroupSyncablesByGroupId(groupID string, syncableType model.GroupSyncableType) ([]*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.GetAllGroupSyncablesByGroupId(groupID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, syncableType}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetAllGroupSyncablesByGroupId", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetByIDs(groupIDs []string) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByIDs(groupIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupIDs}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetByIDs", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetByName(name string, opts model.GroupSearchOpts) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByName(name, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{name, opts}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetByRemoteID(remoteID string, groupSource model.GroupSource) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByRemoteID(remoteID, groupSource)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remoteID, groupSource}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetByRemoteID", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetByUser(userID string) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetGroupSyncable(groupID string, syncableID string, syncableType model.GroupSyncableType) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupSyncable(groupID, syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, syncableID, syncableType}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetGroupSyncable", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetGroups(page int, perPage int, opts model.GroupSearchOpts, viewRestrictions *model.ViewUsersRestrictions) ([]*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroups(page, perPage, opts, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{page, perPage, opts, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetGroups", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetGroupsAssociatedToChannelsByTeam(teamID string, opts model.GroupSearchOpts) (map[string][]*model.GroupWithSchemeAdmin, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupsAssociatedToChannelsByTeam(teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, opts}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetGroupsAssociatedToChannelsByTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetGroupsByChannel(channelID string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupsByChannel(channelID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, opts}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetGroupsByChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetGroupsByTeam(teamID string, opts model.GroupSearchOpts) ([]*model.GroupWithSchemeAdmin, error) {
	start := time.Now()

	result, err := s.GroupStore.GetGroupsByTeam(teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, opts}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetGroupsByTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMember(groupID string, userID string) (*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMember(groupID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, userID}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMemberCount(groupID string) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberCount(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMemberCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMemberCountWithRestrictions(groupID string, viewRestrictions *model.ViewUsersRestrictions) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberCountWithRestrictions(groupID, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMemberCountWithRestrictions", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMemberUsers(groupID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsers(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMemberUsers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMemberUsersInTeam(groupID string, teamID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersInTeam(groupID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, teamID}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMemberUsersInTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMemberUsersNotInChannel(groupID string, channelID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersNotInChannel(groupID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, channelID}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMemberUsersNotInChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMemberUsersPage(groupID string, page int, perPage int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersPage(groupID, page, perPage, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, page, perPage, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMemberUsersPage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetMemberUsersSortedPage(groupID string, page int, perPage int, viewRestrictions *model.ViewUsersRestrictions, teammateNameDisplay string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetMemberUsersSortedPage(groupID, page, perPage, viewRestrictions, teammateNameDisplay)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, page, perPage, viewRestrictions, teammateNameDisplay}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetMemberUsersSortedPage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GetNonMemberUsersPage(groupID string, page int, perPage int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.GroupStore.GetNonMemberUsersPage(groupID, page, perPage, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, page, perPage, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("GroupStore.GetNonMemberUsersPage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GroupChannelCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupChannelCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("GroupStore.GroupChannelCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GroupCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("GroupStore.GroupCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GroupCountBySource(source model.GroupSource) (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupCountBySource(source)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{source}))
	s.Root.debugBar.SendStoreCall("GroupStore.GroupCountBySource", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GroupCountWithAllowReference() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupCountWithAllowReference()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("GroupStore.GroupCountWithAllowReference", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GroupMemberCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupMemberCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("GroupStore.GroupMemberCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) GroupTeamCount() (int64, error) {
	start := time.Now()

	result, err := s.GroupStore.GroupTeamCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("GroupStore.GroupTeamCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) PermanentDeleteMembersByUser(userID string) error {
	start := time.Now()

	err := s.GroupStore.PermanentDeleteMembersByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("GroupStore.PermanentDeleteMembersByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerGroupStore) PermittedSyncableAdmins(syncableID string, syncableType model.GroupSyncableType) ([]string, error) {
	start := time.Now()

	result, err := s.GroupStore.PermittedSyncableAdmins(syncableID, syncableType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{syncableID, syncableType}))
	s.Root.debugBar.SendStoreCall("GroupStore.PermittedSyncableAdmins", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) Restore(groupID string) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Restore(groupID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID}))
	s.Root.debugBar.SendStoreCall("GroupStore.Restore", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) TeamMembersMinusGroupMembers(teamID string, groupIDs []string, page int, perPage int) ([]*model.UserWithGroups, error) {
	start := time.Now()

	result, err := s.GroupStore.TeamMembersMinusGroupMembers(teamID, groupIDs, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, groupIDs, page, perPage}))
	s.Root.debugBar.SendStoreCall("GroupStore.TeamMembersMinusGroupMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) TeamMembersToAdd(since int64, teamID *string, includeRemovedMembers bool) ([]*model.UserTeamIDPair, error) {
	start := time.Now()

	result, err := s.GroupStore.TeamMembersToAdd(since, teamID, includeRemovedMembers)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{since, teamID, includeRemovedMembers}))
	s.Root.debugBar.SendStoreCall("GroupStore.TeamMembersToAdd", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) TeamMembersToRemove(teamID *string) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.GroupStore.TeamMembersToRemove(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("GroupStore.TeamMembersToRemove", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) Update(group *model.Group) (*model.Group, error) {
	start := time.Now()

	result, err := s.GroupStore.Update(group)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{group}))
	s.Root.debugBar.SendStoreCall("GroupStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) UpdateGroupSyncable(groupSyncable *model.GroupSyncable) (*model.GroupSyncable, error) {
	start := time.Now()

	result, err := s.GroupStore.UpdateGroupSyncable(groupSyncable)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupSyncable}))
	s.Root.debugBar.SendStoreCall("GroupStore.UpdateGroupSyncable", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) UpsertMember(groupID string, userID string) (*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.UpsertMember(groupID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, userID}))
	s.Root.debugBar.SendStoreCall("GroupStore.UpsertMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerGroupStore) UpsertMembers(groupID string, userIDs []string) ([]*model.GroupMember, error) {
	start := time.Now()

	result, err := s.GroupStore.UpsertMembers(groupID, userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, userIDs}))
	s.Root.debugBar.SendStoreCall("GroupStore.UpsertMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) Cleanup(expiryTime int64, batchSize int) error {
	start := time.Now()

	err := s.JobStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{expiryTime, batchSize}))
	s.Root.debugBar.SendStoreCall("JobStore.Cleanup", success, elapsed)
	return err
}

func (s *DebugBarLayerJobStore) Delete(id string) (string, error) {
	start := time.Now()

	result, err := s.JobStore.Delete(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("JobStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) Get(id string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("JobStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetAllByStatus(status string) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByStatus(status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{status}))
	s.Root.debugBar.SendStoreCall("JobStore.GetAllByStatus", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetAllByType(jobType string) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByType(jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{jobType}))
	s.Root.debugBar.SendStoreCall("JobStore.GetAllByType", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetAllByTypeAndStatus(jobType string, status string) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByTypeAndStatus(jobType, status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{jobType, status}))
	s.Root.debugBar.SendStoreCall("JobStore.GetAllByTypeAndStatus", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetAllByTypePage(jobType string, offset int, limit int) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByTypePage(jobType, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{jobType, offset, limit}))
	s.Root.debugBar.SendStoreCall("JobStore.GetAllByTypePage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetAllByTypesPage(jobTypes []string, offset int, limit int) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllByTypesPage(jobTypes, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{jobTypes, offset, limit}))
	s.Root.debugBar.SendStoreCall("JobStore.GetAllByTypesPage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetAllPage(offset int, limit int) ([]*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetAllPage(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit}))
	s.Root.debugBar.SendStoreCall("JobStore.GetAllPage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetCountByStatusAndType(status string, jobType string) (int64, error) {
	start := time.Now()

	result, err := s.JobStore.GetCountByStatusAndType(status, jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{status, jobType}))
	s.Root.debugBar.SendStoreCall("JobStore.GetCountByStatusAndType", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetNewestJobByStatusAndType(status string, jobType string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetNewestJobByStatusAndType(status, jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{status, jobType}))
	s.Root.debugBar.SendStoreCall("JobStore.GetNewestJobByStatusAndType", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) GetNewestJobByStatusesAndType(statuses []string, jobType string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.GetNewestJobByStatusesAndType(statuses, jobType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{statuses, jobType}))
	s.Root.debugBar.SendStoreCall("JobStore.GetNewestJobByStatusesAndType", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) Save(job *model.Job) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.Save(job)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{job}))
	s.Root.debugBar.SendStoreCall("JobStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) UpdateOptimistically(job *model.Job, currentStatus string) (bool, error) {
	start := time.Now()

	result, err := s.JobStore.UpdateOptimistically(job, currentStatus)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{job, currentStatus}))
	s.Root.debugBar.SendStoreCall("JobStore.UpdateOptimistically", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) UpdateStatus(id string, status string) (*model.Job, error) {
	start := time.Now()

	result, err := s.JobStore.UpdateStatus(id, status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, status}))
	s.Root.debugBar.SendStoreCall("JobStore.UpdateStatus", success, elapsed)
	return result, err
}

func (s *DebugBarLayerJobStore) UpdateStatusOptimistically(id string, currentStatus string, newStatus string) (bool, error) {
	start := time.Now()

	result, err := s.JobStore.UpdateStatusOptimistically(id, currentStatus, newStatus)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, currentStatus, newStatus}))
	s.Root.debugBar.SendStoreCall("JobStore.UpdateStatusOptimistically", success, elapsed)
	return result, err
}

func (s *DebugBarLayerLicenseStore) Get(id string) (*model.LicenseRecord, error) {
	start := time.Now()

	result, err := s.LicenseStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("LicenseStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerLicenseStore) GetAll() ([]*model.LicenseRecord, error) {
	start := time.Now()

	result, err := s.LicenseStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("LicenseStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerLicenseStore) Save(license *model.LicenseRecord) (*model.LicenseRecord, error) {
	start := time.Now()

	result, err := s.LicenseStore.Save(license)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{license}))
	s.Root.debugBar.SendStoreCall("LicenseStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerLinkMetadataStore) Get(url string, timestamp int64) (*model.LinkMetadata, error) {
	start := time.Now()

	result, err := s.LinkMetadataStore.Get(url, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{url, timestamp}))
	s.Root.debugBar.SendStoreCall("LinkMetadataStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerLinkMetadataStore) Save(linkMetadata *model.LinkMetadata) (*model.LinkMetadata, error) {
	start := time.Now()

	result, err := s.LinkMetadataStore.Save(linkMetadata)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{linkMetadata}))
	s.Root.debugBar.SendStoreCall("LinkMetadataStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerNotifyAdminStore) DeleteBefore(trial bool, now int64) error {
	start := time.Now()

	err := s.NotifyAdminStore.DeleteBefore(trial, now)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{trial, now}))
	s.Root.debugBar.SendStoreCall("NotifyAdminStore.DeleteBefore", success, elapsed)
	return err
}

func (s *DebugBarLayerNotifyAdminStore) Get(trial bool) ([]*model.NotifyAdminData, error) {
	start := time.Now()

	result, err := s.NotifyAdminStore.Get(trial)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{trial}))
	s.Root.debugBar.SendStoreCall("NotifyAdminStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerNotifyAdminStore) GetDataByUserIdAndFeature(userId string, feature model.MattermostFeature) ([]*model.NotifyAdminData, error) {
	start := time.Now()

	result, err := s.NotifyAdminStore.GetDataByUserIdAndFeature(userId, feature)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, feature}))
	s.Root.debugBar.SendStoreCall("NotifyAdminStore.GetDataByUserIdAndFeature", success, elapsed)
	return result, err
}

func (s *DebugBarLayerNotifyAdminStore) Save(data *model.NotifyAdminData) (*model.NotifyAdminData, error) {
	start := time.Now()

	result, err := s.NotifyAdminStore.Save(data)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{data}))
	s.Root.debugBar.SendStoreCall("NotifyAdminStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerNotifyAdminStore) Update(userId string, requiredPlan string, requiredFeature model.MattermostFeature, now int64) error {
	start := time.Now()

	err := s.NotifyAdminStore.Update(userId, requiredPlan, requiredFeature, now)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, requiredPlan, requiredFeature, now}))
	s.Root.debugBar.SendStoreCall("NotifyAdminStore.Update", success, elapsed)
	return err
}

func (s *DebugBarLayerOAuthStore) DeleteApp(id string) error {
	start := time.Now()

	err := s.OAuthStore.DeleteApp(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("OAuthStore.DeleteApp", success, elapsed)
	return err
}

func (s *DebugBarLayerOAuthStore) GetAccessData(token string) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAccessData(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{token}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetAccessData", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetAccessDataByRefreshToken(token string) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAccessDataByRefreshToken(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{token}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetAccessDataByRefreshToken", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetAccessDataByUserForApp(userID string, clientId string) ([]*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAccessDataByUserForApp(userID, clientId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, clientId}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetAccessDataByUserForApp", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetApp(id string) (*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetApp(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetApp", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetAppByUser(userID string, offset int, limit int) ([]*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAppByUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetAppByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetApps(offset int, limit int) ([]*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetApps(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetApps", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetAuthData(code string) (*model.AuthData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAuthData(code)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{code}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetAuthData", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetAuthorizedApps(userID string, offset int, limit int) ([]*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetAuthorizedApps(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetAuthorizedApps", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) GetPreviousAccessData(userID string, clientId string) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.GetPreviousAccessData(userID, clientId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, clientId}))
	s.Root.debugBar.SendStoreCall("OAuthStore.GetPreviousAccessData", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) PermanentDeleteAuthDataByUser(userID string) error {
	start := time.Now()

	err := s.OAuthStore.PermanentDeleteAuthDataByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("OAuthStore.PermanentDeleteAuthDataByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerOAuthStore) RemoveAccessData(token string) error {
	start := time.Now()

	err := s.OAuthStore.RemoveAccessData(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{token}))
	s.Root.debugBar.SendStoreCall("OAuthStore.RemoveAccessData", success, elapsed)
	return err
}

func (s *DebugBarLayerOAuthStore) RemoveAllAccessData() error {
	start := time.Now()

	err := s.OAuthStore.RemoveAllAccessData()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("OAuthStore.RemoveAllAccessData", success, elapsed)
	return err
}

func (s *DebugBarLayerOAuthStore) RemoveAuthData(code string) error {
	start := time.Now()

	err := s.OAuthStore.RemoveAuthData(code)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{code}))
	s.Root.debugBar.SendStoreCall("OAuthStore.RemoveAuthData", success, elapsed)
	return err
}

func (s *DebugBarLayerOAuthStore) SaveAccessData(accessData *model.AccessData) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.SaveAccessData(accessData)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{accessData}))
	s.Root.debugBar.SendStoreCall("OAuthStore.SaveAccessData", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) SaveApp(app *model.OAuthApp) (*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.SaveApp(app)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{app}))
	s.Root.debugBar.SendStoreCall("OAuthStore.SaveApp", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) SaveAuthData(authData *model.AuthData) (*model.AuthData, error) {
	start := time.Now()

	result, err := s.OAuthStore.SaveAuthData(authData)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{authData}))
	s.Root.debugBar.SendStoreCall("OAuthStore.SaveAuthData", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) UpdateAccessData(accessData *model.AccessData) (*model.AccessData, error) {
	start := time.Now()

	result, err := s.OAuthStore.UpdateAccessData(accessData)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{accessData}))
	s.Root.debugBar.SendStoreCall("OAuthStore.UpdateAccessData", success, elapsed)
	return result, err
}

func (s *DebugBarLayerOAuthStore) UpdateApp(app *model.OAuthApp) (*model.OAuthApp, error) {
	start := time.Now()

	result, err := s.OAuthStore.UpdateApp(app)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{app}))
	s.Root.debugBar.SendStoreCall("OAuthStore.UpdateApp", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPluginStore) CompareAndDelete(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := time.Now()

	result, err := s.PluginStore.CompareAndDelete(keyVal, oldValue)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{keyVal, oldValue}))
	s.Root.debugBar.SendStoreCall("PluginStore.CompareAndDelete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPluginStore) CompareAndSet(keyVal *model.PluginKeyValue, oldValue []byte) (bool, error) {
	start := time.Now()

	result, err := s.PluginStore.CompareAndSet(keyVal, oldValue)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{keyVal, oldValue}))
	s.Root.debugBar.SendStoreCall("PluginStore.CompareAndSet", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPluginStore) Delete(pluginID string, key string) error {
	start := time.Now()

	err := s.PluginStore.Delete(pluginID, key)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{pluginID, key}))
	s.Root.debugBar.SendStoreCall("PluginStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerPluginStore) DeleteAllExpired() error {
	start := time.Now()

	err := s.PluginStore.DeleteAllExpired()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("PluginStore.DeleteAllExpired", success, elapsed)
	return err
}

func (s *DebugBarLayerPluginStore) DeleteAllForPlugin(PluginID string) error {
	start := time.Now()

	err := s.PluginStore.DeleteAllForPlugin(PluginID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{PluginID}))
	s.Root.debugBar.SendStoreCall("PluginStore.DeleteAllForPlugin", success, elapsed)
	return err
}

func (s *DebugBarLayerPluginStore) Get(pluginID string, key string) (*model.PluginKeyValue, error) {
	start := time.Now()

	result, err := s.PluginStore.Get(pluginID, key)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{pluginID, key}))
	s.Root.debugBar.SendStoreCall("PluginStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPluginStore) List(pluginID string, page int, perPage int) ([]string, error) {
	start := time.Now()

	result, err := s.PluginStore.List(pluginID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{pluginID, page, perPage}))
	s.Root.debugBar.SendStoreCall("PluginStore.List", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPluginStore) SaveOrUpdate(keyVal *model.PluginKeyValue) (*model.PluginKeyValue, error) {
	start := time.Now()

	result, err := s.PluginStore.SaveOrUpdate(keyVal)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{keyVal}))
	s.Root.debugBar.SendStoreCall("PluginStore.SaveOrUpdate", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPluginStore) SetWithOptions(pluginID string, key string, value []byte, options model.PluginKVSetOptions) (bool, error) {
	start := time.Now()

	result, err := s.PluginStore.SetWithOptions(pluginID, key, value, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{pluginID, key, value, options}))
	s.Root.debugBar.SendStoreCall("PluginStore.SetWithOptions", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) AnalyticsPostCount(options *model.PostCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.AnalyticsPostCount(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("PostStore.AnalyticsPostCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) AnalyticsPostCountsByDay(options *model.AnalyticsPostCountsOptions) (model.AnalyticsRows, error) {
	start := time.Now()

	result, err := s.PostStore.AnalyticsPostCountsByDay(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("PostStore.AnalyticsPostCountsByDay", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) AnalyticsUserCountsWithPostsByDay(teamID string) (model.AnalyticsRows, error) {
	start := time.Now()

	result, err := s.PostStore.AnalyticsUserCountsWithPostsByDay(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("PostStore.AnalyticsUserCountsWithPostsByDay", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) ClearCaches() {
	start := time.Now()

	s.PostStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("PostStore.ClearCaches", success, elapsed)

}

func (s *DebugBarLayerPostStore) Delete(postID string, timestamp int64, deleteByID string) error {
	start := time.Now()

	err := s.PostStore.Delete(postID, timestamp, deleteByID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID, timestamp, deleteByID}))
	s.Root.debugBar.SendStoreCall("PostStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerPostStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit}))
	s.Root.debugBar.SendStoreCall("PostStore.DeleteOrphanedRows", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) Get(ctx context.Context, id string, opts model.GetPostsOptions, userID string, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.Get(ctx, id, opts, userID, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, id, opts, userID, sanitizeOptions}))
	s.Root.debugBar.SendStoreCall("PostStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetDirectPostParentsForExportAfter(limit int, afterID string) ([]*model.DirectPostForExport, error) {
	start := time.Now()

	result, err := s.PostStore.GetDirectPostParentsForExportAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit, afterID}))
	s.Root.debugBar.SendStoreCall("PostStore.GetDirectPostParentsForExportAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetEditHistoryForPost(postId string) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetEditHistoryForPost(postId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postId}))
	s.Root.debugBar.SendStoreCall("PostStore.GetEditHistoryForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetEtag(channelID string, allowFromCache bool, collapsedThreads bool) string {
	start := time.Now()

	result := s.PostStore.GetEtag(channelID, allowFromCache, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, allowFromCache, collapsedThreads}))
	s.Root.debugBar.SendStoreCall("PostStore.GetEtag", success, elapsed)
	return result
}

func (s *DebugBarLayerPostStore) GetFlaggedPosts(userID string, offset int, limit int) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetFlaggedPosts(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("PostStore.GetFlaggedPosts", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetFlaggedPostsForChannel(userID string, channelID string, offset int, limit int) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetFlaggedPostsForChannel(userID, channelID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID, offset, limit}))
	s.Root.debugBar.SendStoreCall("PostStore.GetFlaggedPostsForChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetFlaggedPostsForTeam(userID string, teamID string, offset int, limit int) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetFlaggedPostsForTeam(userID, teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, offset, limit}))
	s.Root.debugBar.SendStoreCall("PostStore.GetFlaggedPostsForTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetLastPostRowCreateAt() (int64, error) {
	start := time.Now()

	result, err := s.PostStore.GetLastPostRowCreateAt()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("PostStore.GetLastPostRowCreateAt", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetMaxPostSize() int {
	start := time.Now()

	result := s.PostStore.GetMaxPostSize()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("PostStore.GetMaxPostSize", success, elapsed)
	return result
}

func (s *DebugBarLayerPostStore) GetNthRecentPostTime(n int64) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.GetNthRecentPostTime(n)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{n}))
	s.Root.debugBar.SendStoreCall("PostStore.GetNthRecentPostTime", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetOldest() (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetOldest()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("PostStore.GetOldest", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetOldestEntityCreationTime() (int64, error) {
	start := time.Now()

	result, err := s.PostStore.GetOldestEntityCreationTime()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("PostStore.GetOldestEntityCreationTime", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetParentsForExportAfter(limit int, afterID string) ([]*model.PostForExport, error) {
	start := time.Now()

	result, err := s.PostStore.GetParentsForExportAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit, afterID}))
	s.Root.debugBar.SendStoreCall("PostStore.GetParentsForExportAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostAfterTime(channelID string, timestamp int64, collapsedThreads bool) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostAfterTime(channelID, timestamp, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp, collapsedThreads}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostAfterTime", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostIdAfterTime(channelID string, timestamp int64, collapsedThreads bool) (string, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostIdAfterTime(channelID, timestamp, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp, collapsedThreads}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostIdAfterTime", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostIdBeforeTime(channelID string, timestamp int64, collapsedThreads bool) (string, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostIdBeforeTime(channelID, timestamp, collapsedThreads)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp, collapsedThreads}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostIdBeforeTime", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostReminderMetadata(postID string) (*store.PostReminderMetadata, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostReminderMetadata(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostReminderMetadata", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostReminders(now int64) ([]*model.PostReminder, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostReminders(now)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{now}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostReminders", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPosts(options model.GetPostsOptions, allowFromCache bool, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPosts(options, allowFromCache, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options, allowFromCache, sanitizeOptions}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPosts", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsAfter(options model.GetPostsOptions, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsAfter(options, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options, sanitizeOptions}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsBatchForIndexing(startTime int64, startPostID string, limit int) ([]*model.PostForIndexing, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsBatchForIndexing(startTime, startPostID, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{startTime, startPostID, limit}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsBatchForIndexing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsBefore(options model.GetPostsOptions, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsBefore(options, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options, sanitizeOptions}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsBefore", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsByIds(postIds []string) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsByIds(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postIds}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsByThread(threadID string, since int64) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsByThread(threadID, since)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{threadID, since}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsByThread", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsCreatedAt(channelID string, timestamp int64) ([]*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsCreatedAt(channelID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, timestamp}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsCreatedAt", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsSince(options model.GetPostsSinceOptions, allowFromCache bool, sanitizeOptions map[string]bool) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.GetPostsSince(options, allowFromCache, sanitizeOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options, allowFromCache, sanitizeOptions}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetPostsSinceForSync(options model.GetPostsSinceForSyncOptions, cursor model.GetPostsSinceForSyncCursor, limit int) ([]*model.Post, model.GetPostsSinceForSyncCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.GetPostsSinceForSync(options, cursor, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options, cursor, limit}))
	s.Root.debugBar.SendStoreCall("PostStore.GetPostsSinceForSync", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerPostStore) GetRecentSearchesForUser(userID string) ([]*model.SearchParams, error) {
	start := time.Now()

	result, err := s.PostStore.GetRecentSearchesForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("PostStore.GetRecentSearchesForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetRepliesForExport(parentID string) ([]*model.ReplyForExport, error) {
	start := time.Now()

	result, err := s.PostStore.GetRepliesForExport(parentID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{parentID}))
	s.Root.debugBar.SendStoreCall("PostStore.GetRepliesForExport", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetSingle(id string, inclDeleted bool) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.GetSingle(id, inclDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, inclDeleted}))
	s.Root.debugBar.SendStoreCall("PostStore.GetSingle", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) GetTopDMsForUserSince(userID string, since int64, offset int, limit int) (*model.TopDMList, error) {
	start := time.Now()

	result, err := s.PostStore.GetTopDMsForUserSince(userID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("PostStore.GetTopDMsForUserSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) HasAutoResponsePostByUserSince(options model.GetPostsSinceOptions, userId string) (bool, error) {
	start := time.Now()

	result, err := s.PostStore.HasAutoResponsePostByUserSince(options, userId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options, userId}))
	s.Root.debugBar.SendStoreCall("PostStore.HasAutoResponsePostByUserSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) InvalidateLastPostTimeCache(channelID string) {
	start := time.Now()

	s.PostStore.InvalidateLastPostTimeCache(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("PostStore.InvalidateLastPostTimeCache", success, elapsed)

}

func (s *DebugBarLayerPostStore) LogRecentSearch(userID string, searchQuery []byte, createAt int64) error {
	start := time.Now()

	err := s.PostStore.LogRecentSearch(userID, searchQuery, createAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, searchQuery, createAt}))
	s.Root.debugBar.SendStoreCall("PostStore.LogRecentSearch", success, elapsed)
	return err
}

func (s *DebugBarLayerPostStore) Overwrite(post *model.Post) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.Overwrite(post)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{post}))
	s.Root.debugBar.SendStoreCall("PostStore.Overwrite", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) OverwriteMultiple(posts []*model.Post) ([]*model.Post, int, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.OverwriteMultiple(posts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{posts}))
	s.Root.debugBar.SendStoreCall("PostStore.OverwriteMultiple", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerPostStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.PostStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{endTime, limit}))
	s.Root.debugBar.SendStoreCall("PostStore.PermanentDeleteBatch", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) PermanentDeleteBatchForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.PermanentDeleteBatchForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{now, globalPolicyEndTime, limit, cursor}))
	s.Root.debugBar.SendStoreCall("PostStore.PermanentDeleteBatchForRetentionPolicies", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerPostStore) PermanentDeleteByChannel(channelID string) error {
	start := time.Now()

	err := s.PostStore.PermanentDeleteByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("PostStore.PermanentDeleteByChannel", success, elapsed)
	return err
}

func (s *DebugBarLayerPostStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.PostStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("PostStore.PermanentDeleteByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerPostStore) Save(post *model.Post) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.Save(post)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{post}))
	s.Root.debugBar.SendStoreCall("PostStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) SaveMultiple(posts []*model.Post) ([]*model.Post, int, error) {
	start := time.Now()

	result, resultVar1, err := s.PostStore.SaveMultiple(posts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{posts}))
	s.Root.debugBar.SendStoreCall("PostStore.SaveMultiple", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerPostStore) Search(teamID string, userID string, params *model.SearchParams) (*model.PostList, error) {
	start := time.Now()

	result, err := s.PostStore.Search(teamID, userID, params)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, params}))
	s.Root.debugBar.SendStoreCall("PostStore.Search", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) SearchPostsForUser(paramsList []*model.SearchParams, userID string, teamID string, page int, perPage int) (*model.PostSearchResults, error) {
	start := time.Now()

	result, err := s.PostStore.SearchPostsForUser(paramsList, userID, teamID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{paramsList, userID, teamID, page, perPage}))
	s.Root.debugBar.SendStoreCall("PostStore.SearchPostsForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostStore) SetPostReminder(reminder *model.PostReminder) error {
	start := time.Now()

	err := s.PostStore.SetPostReminder(reminder)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{reminder}))
	s.Root.debugBar.SendStoreCall("PostStore.SetPostReminder", success, elapsed)
	return err
}

func (s *DebugBarLayerPostStore) Update(newPost *model.Post, oldPost *model.Post) (*model.Post, error) {
	start := time.Now()

	result, err := s.PostStore.Update(newPost, oldPost)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{newPost, oldPost}))
	s.Root.debugBar.SendStoreCall("PostStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostAcknowledgementStore) Delete(acknowledgement *model.PostAcknowledgement) error {
	start := time.Now()

	err := s.PostAcknowledgementStore.Delete(acknowledgement)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{acknowledgement}))
	s.Root.debugBar.SendStoreCall("PostAcknowledgementStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerPostAcknowledgementStore) Get(postID string, userID string) (*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.Get(postID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID, userID}))
	s.Root.debugBar.SendStoreCall("PostAcknowledgementStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostAcknowledgementStore) GetForPost(postID string) ([]*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.GetForPost(postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID}))
	s.Root.debugBar.SendStoreCall("PostAcknowledgementStore.GetForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostAcknowledgementStore) GetForPosts(postIds []string) ([]*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.GetForPosts(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postIds}))
	s.Root.debugBar.SendStoreCall("PostAcknowledgementStore.GetForPosts", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostAcknowledgementStore) Save(postID string, userID string, acknowledgedAt int64) (*model.PostAcknowledgement, error) {
	start := time.Now()

	result, err := s.PostAcknowledgementStore.Save(postID, userID, acknowledgedAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID, userID, acknowledgedAt}))
	s.Root.debugBar.SendStoreCall("PostAcknowledgementStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostPriorityStore) GetForPost(postId string) (*model.PostPriority, error) {
	start := time.Now()

	result, err := s.PostPriorityStore.GetForPost(postId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postId}))
	s.Root.debugBar.SendStoreCall("PostPriorityStore.GetForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPostPriorityStore) GetForPosts(ids []string) ([]*model.PostPriority, error) {
	start := time.Now()

	result, err := s.PostPriorityStore.GetForPosts(ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ids}))
	s.Root.debugBar.SendStoreCall("PostPriorityStore.GetForPosts", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPreferenceStore) CleanupFlagsBatch(limit int64) (int64, error) {
	start := time.Now()

	result, err := s.PreferenceStore.CleanupFlagsBatch(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.CleanupFlagsBatch", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPreferenceStore) Delete(userID string, category string, name string) error {
	start := time.Now()

	err := s.PreferenceStore.Delete(userID, category, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, category, name}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerPreferenceStore) DeleteCategory(userID string, category string) error {
	start := time.Now()

	err := s.PreferenceStore.DeleteCategory(userID, category)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, category}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.DeleteCategory", success, elapsed)
	return err
}

func (s *DebugBarLayerPreferenceStore) DeleteCategoryAndName(category string, name string) error {
	start := time.Now()

	err := s.PreferenceStore.DeleteCategoryAndName(category, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{category, name}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.DeleteCategoryAndName", success, elapsed)
	return err
}

func (s *DebugBarLayerPreferenceStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.PreferenceStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.DeleteOrphanedRows", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPreferenceStore) Get(userID string, category string, name string) (*model.Preference, error) {
	start := time.Now()

	result, err := s.PreferenceStore.Get(userID, category, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, category, name}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPreferenceStore) GetAll(userID string) (model.Preferences, error) {
	start := time.Now()

	result, err := s.PreferenceStore.GetAll(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPreferenceStore) GetCategory(userID string, category string) (model.Preferences, error) {
	start := time.Now()

	result, err := s.PreferenceStore.GetCategory(userID, category)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, category}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.GetCategory", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPreferenceStore) GetCategoryAndName(category string, nane string) (model.Preferences, error) {
	start := time.Now()

	result, err := s.PreferenceStore.GetCategoryAndName(category, nane)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{category, nane}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.GetCategoryAndName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerPreferenceStore) PermanentDeleteByUser(userID string) error {
	start := time.Now()

	err := s.PreferenceStore.PermanentDeleteByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.PermanentDeleteByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerPreferenceStore) Save(preferences model.Preferences) error {
	start := time.Now()

	err := s.PreferenceStore.Save(preferences)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{preferences}))
	s.Root.debugBar.SendStoreCall("PreferenceStore.Save", success, elapsed)
	return err
}

func (s *DebugBarLayerProductNoticesStore) Clear(notices []string) error {
	start := time.Now()

	err := s.ProductNoticesStore.Clear(notices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{notices}))
	s.Root.debugBar.SendStoreCall("ProductNoticesStore.Clear", success, elapsed)
	return err
}

func (s *DebugBarLayerProductNoticesStore) ClearOldNotices(currentNotices model.ProductNotices) error {
	start := time.Now()

	err := s.ProductNoticesStore.ClearOldNotices(currentNotices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{currentNotices}))
	s.Root.debugBar.SendStoreCall("ProductNoticesStore.ClearOldNotices", success, elapsed)
	return err
}

func (s *DebugBarLayerProductNoticesStore) GetViews(userID string) ([]model.ProductNoticeViewState, error) {
	start := time.Now()

	result, err := s.ProductNoticesStore.GetViews(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("ProductNoticesStore.GetViews", success, elapsed)
	return result, err
}

func (s *DebugBarLayerProductNoticesStore) View(userID string, notices []string) error {
	start := time.Now()

	err := s.ProductNoticesStore.View(userID, notices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, notices}))
	s.Root.debugBar.SendStoreCall("ProductNoticesStore.View", success, elapsed)
	return err
}

func (s *DebugBarLayerReactionStore) BulkGetForPosts(postIds []string) ([]*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.BulkGetForPosts(postIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postIds}))
	s.Root.debugBar.SendStoreCall("ReactionStore.BulkGetForPosts", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) Delete(reaction *model.Reaction) (*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.Delete(reaction)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{reaction}))
	s.Root.debugBar.SendStoreCall("ReactionStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) DeleteAllWithEmojiName(emojiName string) error {
	start := time.Now()

	err := s.ReactionStore.DeleteAllWithEmojiName(emojiName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{emojiName}))
	s.Root.debugBar.SendStoreCall("ReactionStore.DeleteAllWithEmojiName", success, elapsed)
	return err
}

func (s *DebugBarLayerReactionStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.ReactionStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit}))
	s.Root.debugBar.SendStoreCall("ReactionStore.DeleteOrphanedRows", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) GetForPost(postID string, allowFromCache bool) ([]*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetForPost(postID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postID, allowFromCache}))
	s.Root.debugBar.SendStoreCall("ReactionStore.GetForPost", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) GetForPostSince(postId string, since int64, excludeRemoteId string, inclDeleted bool) ([]*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetForPostSince(postId, since, excludeRemoteId, inclDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{postId, since, excludeRemoteId, inclDeleted}))
	s.Root.debugBar.SendStoreCall("ReactionStore.GetForPostSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) GetTopForTeamSince(teamID string, userID string, since int64, offset int, limit int) (*model.TopReactionList, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetTopForTeamSince(teamID, userID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ReactionStore.GetTopForTeamSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) GetTopForUserSince(userID string, teamID string, since int64, offset int, limit int) (*model.TopReactionList, error) {
	start := time.Now()

	result, err := s.ReactionStore.GetTopForUserSince(userID, teamID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ReactionStore.GetTopForUserSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) PermanentDeleteBatch(endTime int64, limit int64) (int64, error) {
	start := time.Now()

	result, err := s.ReactionStore.PermanentDeleteBatch(endTime, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{endTime, limit}))
	s.Root.debugBar.SendStoreCall("ReactionStore.PermanentDeleteBatch", success, elapsed)
	return result, err
}

func (s *DebugBarLayerReactionStore) Save(reaction *model.Reaction) (*model.Reaction, error) {
	start := time.Now()

	result, err := s.ReactionStore.Save(reaction)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{reaction}))
	s.Root.debugBar.SendStoreCall("ReactionStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRemoteClusterStore) Delete(remoteClusterId string) (bool, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Delete(remoteClusterId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remoteClusterId}))
	s.Root.debugBar.SendStoreCall("RemoteClusterStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRemoteClusterStore) Get(remoteClusterId string) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Get(remoteClusterId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remoteClusterId}))
	s.Root.debugBar.SendStoreCall("RemoteClusterStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRemoteClusterStore) GetAll(filter model.RemoteClusterQueryFilter) ([]*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.GetAll(filter)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{filter}))
	s.Root.debugBar.SendStoreCall("RemoteClusterStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRemoteClusterStore) Save(rc *model.RemoteCluster) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Save(rc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{rc}))
	s.Root.debugBar.SendStoreCall("RemoteClusterStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRemoteClusterStore) SetLastPingAt(remoteClusterId string) error {
	start := time.Now()

	err := s.RemoteClusterStore.SetLastPingAt(remoteClusterId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remoteClusterId}))
	s.Root.debugBar.SendStoreCall("RemoteClusterStore.SetLastPingAt", success, elapsed)
	return err
}

func (s *DebugBarLayerRemoteClusterStore) Update(rc *model.RemoteCluster) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.Update(rc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{rc}))
	s.Root.debugBar.SendStoreCall("RemoteClusterStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRemoteClusterStore) UpdateTopics(remoteClusterId string, topics string) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.RemoteClusterStore.UpdateTopics(remoteClusterId, topics)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remoteClusterId, topics}))
	s.Root.debugBar.SendStoreCall("RemoteClusterStore.UpdateTopics", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) AddChannels(policyId string, channelIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.AddChannels(policyId, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId, channelIds}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.AddChannels", success, elapsed)
	return err
}

func (s *DebugBarLayerRetentionPolicyStore) AddTeams(policyId string, teamIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.AddTeams(policyId, teamIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId, teamIds}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.AddTeams", success, elapsed)
	return err
}

func (s *DebugBarLayerRetentionPolicyStore) Delete(id string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.Delete(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerRetentionPolicyStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.DeleteOrphanedRows", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) Get(id string) (*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetAll(offset int, limit int) ([]*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetAll(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetChannelPoliciesCountForUser(userID string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannelPoliciesCountForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetChannelPoliciesCountForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetChannelPoliciesForUser(userID string, offset int, limit int) ([]*model.RetentionPolicyForChannel, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannelPoliciesForUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetChannelPoliciesForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetChannels(policyId string, offset int, limit int) (model.ChannelListWithTeamData, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannels(policyId, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId, offset, limit}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetChannels", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetChannelsCount(policyId string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetChannelsCount(policyId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetChannelsCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetCount() (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetTeamPoliciesCountForUser(userID string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeamPoliciesCountForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetTeamPoliciesCountForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetTeamPoliciesForUser(userID string, offset int, limit int) ([]*model.RetentionPolicyForTeam, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeamPoliciesForUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetTeamPoliciesForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetTeams(policyId string, offset int, limit int) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeams(policyId, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId, offset, limit}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetTeams", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) GetTeamsCount(policyId string) (int64, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.GetTeamsCount(policyId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.GetTeamsCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) Patch(patch *model.RetentionPolicyWithTeamAndChannelIDs) (*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.Patch(patch)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{patch}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.Patch", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRetentionPolicyStore) RemoveChannels(policyId string, channelIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.RemoveChannels(policyId, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId, channelIds}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.RemoveChannels", success, elapsed)
	return err
}

func (s *DebugBarLayerRetentionPolicyStore) RemoveTeams(policyId string, teamIds []string) error {
	start := time.Now()

	err := s.RetentionPolicyStore.RemoveTeams(policyId, teamIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policyId, teamIds}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.RemoveTeams", success, elapsed)
	return err
}

func (s *DebugBarLayerRetentionPolicyStore) Save(policy *model.RetentionPolicyWithTeamAndChannelIDs) (*model.RetentionPolicyWithTeamAndChannelCounts, error) {
	start := time.Now()

	result, err := s.RetentionPolicyStore.Save(policy)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{policy}))
	s.Root.debugBar.SendStoreCall("RetentionPolicyStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) AllChannelSchemeRoles() ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.AllChannelSchemeRoles()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("RoleStore.AllChannelSchemeRoles", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) ChannelHigherScopedPermissions(roleNames []string) (map[string]*model.RolePermissions, error) {
	start := time.Now()

	result, err := s.RoleStore.ChannelHigherScopedPermissions(roleNames)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{roleNames}))
	s.Root.debugBar.SendStoreCall("RoleStore.ChannelHigherScopedPermissions", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) ChannelRolesUnderTeamRole(roleName string) ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.ChannelRolesUnderTeamRole(roleName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{roleName}))
	s.Root.debugBar.SendStoreCall("RoleStore.ChannelRolesUnderTeamRole", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) Delete(roleID string) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.Delete(roleID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{roleID}))
	s.Root.debugBar.SendStoreCall("RoleStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) Get(roleID string) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.Get(roleID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{roleID}))
	s.Root.debugBar.SendStoreCall("RoleStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) GetAll() ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("RoleStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) GetByName(ctx context.Context, name string) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.GetByName(ctx, name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, name}))
	s.Root.debugBar.SendStoreCall("RoleStore.GetByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) GetByNames(names []string) ([]*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.GetByNames(names)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{names}))
	s.Root.debugBar.SendStoreCall("RoleStore.GetByNames", success, elapsed)
	return result, err
}

func (s *DebugBarLayerRoleStore) PermanentDeleteAll() error {
	start := time.Now()

	err := s.RoleStore.PermanentDeleteAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("RoleStore.PermanentDeleteAll", success, elapsed)
	return err
}

func (s *DebugBarLayerRoleStore) Save(role *model.Role) (*model.Role, error) {
	start := time.Now()

	result, err := s.RoleStore.Save(role)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{role}))
	s.Root.debugBar.SendStoreCall("RoleStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSchemeStore) CountByScope(scope string) (int64, error) {
	start := time.Now()

	result, err := s.SchemeStore.CountByScope(scope)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{scope}))
	s.Root.debugBar.SendStoreCall("SchemeStore.CountByScope", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSchemeStore) CountWithoutPermission(scope string, permissionID string, roleScope model.RoleScope, roleType model.RoleType) (int64, error) {
	start := time.Now()

	result, err := s.SchemeStore.CountWithoutPermission(scope, permissionID, roleScope, roleType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{scope, permissionID, roleScope, roleType}))
	s.Root.debugBar.SendStoreCall("SchemeStore.CountWithoutPermission", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSchemeStore) Delete(schemeID string) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.Delete(schemeID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{schemeID}))
	s.Root.debugBar.SendStoreCall("SchemeStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSchemeStore) Get(schemeID string) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.Get(schemeID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{schemeID}))
	s.Root.debugBar.SendStoreCall("SchemeStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSchemeStore) GetAllPage(scope string, offset int, limit int) ([]*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.GetAllPage(scope, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{scope, offset, limit}))
	s.Root.debugBar.SendStoreCall("SchemeStore.GetAllPage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSchemeStore) GetByName(schemeName string) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.GetByName(schemeName)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{schemeName}))
	s.Root.debugBar.SendStoreCall("SchemeStore.GetByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSchemeStore) PermanentDeleteAll() error {
	start := time.Now()

	err := s.SchemeStore.PermanentDeleteAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("SchemeStore.PermanentDeleteAll", success, elapsed)
	return err
}

func (s *DebugBarLayerSchemeStore) Save(scheme *model.Scheme) (*model.Scheme, error) {
	start := time.Now()

	result, err := s.SchemeStore.Save(scheme)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{scheme}))
	s.Root.debugBar.SendStoreCall("SchemeStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) AnalyticsSessionCount() (int64, error) {
	start := time.Now()

	result, err := s.SessionStore.AnalyticsSessionCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("SessionStore.AnalyticsSessionCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) Cleanup(expiryTime int64, batchSize int64) error {
	start := time.Now()

	err := s.SessionStore.Cleanup(expiryTime, batchSize)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{expiryTime, batchSize}))
	s.Root.debugBar.SendStoreCall("SessionStore.Cleanup", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) Get(ctx context.Context, sessionIDOrToken string) (*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.Get(ctx, sessionIDOrToken)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, sessionIDOrToken}))
	s.Root.debugBar.SendStoreCall("SessionStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) GetLastSessionRowCreateAt() (int64, error) {
	start := time.Now()

	result, err := s.SessionStore.GetLastSessionRowCreateAt()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("SessionStore.GetLastSessionRowCreateAt", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) GetSessions(userID string) ([]*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.GetSessions(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("SessionStore.GetSessions", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) GetSessionsExpired(thresholdMillis int64, mobileOnly bool, unnotifiedOnly bool) ([]*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.GetSessionsExpired(thresholdMillis, mobileOnly, unnotifiedOnly)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{thresholdMillis, mobileOnly, unnotifiedOnly}))
	s.Root.debugBar.SendStoreCall("SessionStore.GetSessionsExpired", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) GetSessionsWithActiveDeviceIds(userID string) ([]*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.GetSessionsWithActiveDeviceIds(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("SessionStore.GetSessionsWithActiveDeviceIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) PermanentDeleteSessionsByUser(teamID string) error {
	start := time.Now()

	err := s.SessionStore.PermanentDeleteSessionsByUser(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("SessionStore.PermanentDeleteSessionsByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) Remove(sessionIDOrToken string) error {
	start := time.Now()

	err := s.SessionStore.Remove(sessionIDOrToken)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{sessionIDOrToken}))
	s.Root.debugBar.SendStoreCall("SessionStore.Remove", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) RemoveAllSessions() error {
	start := time.Now()

	err := s.SessionStore.RemoveAllSessions()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("SessionStore.RemoveAllSessions", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) Save(session *model.Session) (*model.Session, error) {
	start := time.Now()

	result, err := s.SessionStore.Save(session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{session}))
	s.Root.debugBar.SendStoreCall("SessionStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) UpdateDeviceId(id string, deviceID string, expiresAt int64) (string, error) {
	start := time.Now()

	result, err := s.SessionStore.UpdateDeviceId(id, deviceID, expiresAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, deviceID, expiresAt}))
	s.Root.debugBar.SendStoreCall("SessionStore.UpdateDeviceId", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSessionStore) UpdateExpiredNotify(sessionid string, notified bool) error {
	start := time.Now()

	err := s.SessionStore.UpdateExpiredNotify(sessionid, notified)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{sessionid, notified}))
	s.Root.debugBar.SendStoreCall("SessionStore.UpdateExpiredNotify", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) UpdateExpiresAt(sessionID string, timestamp int64) error {
	start := time.Now()

	err := s.SessionStore.UpdateExpiresAt(sessionID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{sessionID, timestamp}))
	s.Root.debugBar.SendStoreCall("SessionStore.UpdateExpiresAt", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) UpdateLastActivityAt(sessionID string, timestamp int64) error {
	start := time.Now()

	err := s.SessionStore.UpdateLastActivityAt(sessionID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{sessionID, timestamp}))
	s.Root.debugBar.SendStoreCall("SessionStore.UpdateLastActivityAt", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) UpdateProps(session *model.Session) error {
	start := time.Now()

	err := s.SessionStore.UpdateProps(session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{session}))
	s.Root.debugBar.SendStoreCall("SessionStore.UpdateProps", success, elapsed)
	return err
}

func (s *DebugBarLayerSessionStore) UpdateRoles(userID string, roles string) (string, error) {
	start := time.Now()

	result, err := s.SessionStore.UpdateRoles(userID, roles)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, roles}))
	s.Root.debugBar.SendStoreCall("SessionStore.UpdateRoles", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) Delete(channelId string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Delete(channelId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.Delete", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) DeleteRemote(remoteId string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.DeleteRemote(remoteId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remoteId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.DeleteRemote", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) Get(channelId string) (*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Get(channelId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetAll(offset int, limit int, opts model.SharedChannelFilterOpts) ([]*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetAll(offset, limit, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit, opts}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetAllCount(opts model.SharedChannelFilterOpts) (int64, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetAllCount(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetAllCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetAttachment(fileId string, remoteId string) (*model.SharedChannelAttachment, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetAttachment(fileId, remoteId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{fileId, remoteId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetAttachment", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetRemote(id string) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemote(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetRemote", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetRemoteByIds(channelId string, remoteId string) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemoteByIds(channelId, remoteId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelId, remoteId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetRemoteByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetRemoteForUser(remoteId string, userId string) (*model.RemoteCluster, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemoteForUser(remoteId, userId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remoteId, userId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetRemoteForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetRemotes(opts model.SharedChannelRemoteFilterOpts) ([]*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemotes(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetRemotes", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetRemotesStatus(channelId string) ([]*model.SharedChannelRemoteStatus, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetRemotesStatus(channelId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetRemotesStatus", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetSingleUser(userID string, channelID string, remoteID string) (*model.SharedChannelUser, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetSingleUser(userID, channelID, remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID, remoteID}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetSingleUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetUsersForSync(filter model.GetUsersForSyncFilter) ([]*model.User, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetUsersForSync(filter)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{filter}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetUsersForSync", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) GetUsersForUser(userID string) ([]*model.SharedChannelUser, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.GetUsersForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.GetUsersForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) HasChannel(channelID string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.HasChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.HasChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) HasRemote(channelID string, remoteId string) (bool, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.HasRemote(channelID, remoteId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, remoteId}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.HasRemote", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) Save(sc *model.SharedChannel) (*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Save(sc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{sc}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) SaveAttachment(remote *model.SharedChannelAttachment) (*model.SharedChannelAttachment, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.SaveAttachment(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remote}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.SaveAttachment", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) SaveRemote(remote *model.SharedChannelRemote) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.SaveRemote(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remote}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.SaveRemote", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) SaveUser(remote *model.SharedChannelUser) (*model.SharedChannelUser, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.SaveUser(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remote}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.SaveUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) Update(sc *model.SharedChannel) (*model.SharedChannel, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.Update(sc)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{sc}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) UpdateAttachmentLastSyncAt(id string, syncTime int64) error {
	start := time.Now()

	err := s.SharedChannelStore.UpdateAttachmentLastSyncAt(id, syncTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, syncTime}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.UpdateAttachmentLastSyncAt", success, elapsed)
	return err
}

func (s *DebugBarLayerSharedChannelStore) UpdateRemote(remote *model.SharedChannelRemote) (*model.SharedChannelRemote, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.UpdateRemote(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remote}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.UpdateRemote", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSharedChannelStore) UpdateRemoteCursor(id string, cursor model.GetPostsSinceForSyncCursor) error {
	start := time.Now()

	err := s.SharedChannelStore.UpdateRemoteCursor(id, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, cursor}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.UpdateRemoteCursor", success, elapsed)
	return err
}

func (s *DebugBarLayerSharedChannelStore) UpdateUserLastSyncAt(userID string, channelID string, remoteID string) error {
	start := time.Now()

	err := s.SharedChannelStore.UpdateUserLastSyncAt(userID, channelID, remoteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID, remoteID}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.UpdateUserLastSyncAt", success, elapsed)
	return err
}

func (s *DebugBarLayerSharedChannelStore) UpsertAttachment(remote *model.SharedChannelAttachment) (string, error) {
	start := time.Now()

	result, err := s.SharedChannelStore.UpsertAttachment(remote)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{remote}))
	s.Root.debugBar.SendStoreCall("SharedChannelStore.UpsertAttachment", success, elapsed)
	return result, err
}

func (s *DebugBarLayerStatusStore) Get(userID string) (*model.Status, error) {
	start := time.Now()

	result, err := s.StatusStore.Get(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("StatusStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerStatusStore) GetByIds(userIds []string) ([]*model.Status, error) {
	start := time.Now()

	result, err := s.StatusStore.GetByIds(userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userIds}))
	s.Root.debugBar.SendStoreCall("StatusStore.GetByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerStatusStore) GetTotalActiveUsersCount() (int64, error) {
	start := time.Now()

	result, err := s.StatusStore.GetTotalActiveUsersCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("StatusStore.GetTotalActiveUsersCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerStatusStore) ResetAll() error {
	start := time.Now()

	err := s.StatusStore.ResetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("StatusStore.ResetAll", success, elapsed)
	return err
}

func (s *DebugBarLayerStatusStore) SaveOrUpdate(status *model.Status) error {
	start := time.Now()

	err := s.StatusStore.SaveOrUpdate(status)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{status}))
	s.Root.debugBar.SendStoreCall("StatusStore.SaveOrUpdate", success, elapsed)
	return err
}

func (s *DebugBarLayerStatusStore) UpdateExpiredDNDStatuses() ([]*model.Status, error) {
	start := time.Now()

	result, err := s.StatusStore.UpdateExpiredDNDStatuses()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("StatusStore.UpdateExpiredDNDStatuses", success, elapsed)
	return result, err
}

func (s *DebugBarLayerStatusStore) UpdateLastActivityAt(userID string, lastActivityAt int64) error {
	start := time.Now()

	err := s.StatusStore.UpdateLastActivityAt(userID, lastActivityAt)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, lastActivityAt}))
	s.Root.debugBar.SendStoreCall("StatusStore.UpdateLastActivityAt", success, elapsed)
	return err
}

func (s *DebugBarLayerSystemStore) Get() (model.StringMap, error) {
	start := time.Now()

	result, err := s.SystemStore.Get()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("SystemStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSystemStore) GetByName(name string) (*model.System, error) {
	start := time.Now()

	result, err := s.SystemStore.GetByName(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{name}))
	s.Root.debugBar.SendStoreCall("SystemStore.GetByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSystemStore) InsertIfExists(system *model.System) (*model.System, error) {
	start := time.Now()

	result, err := s.SystemStore.InsertIfExists(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{system}))
	s.Root.debugBar.SendStoreCall("SystemStore.InsertIfExists", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSystemStore) PermanentDeleteByName(name string) (*model.System, error) {
	start := time.Now()

	result, err := s.SystemStore.PermanentDeleteByName(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{name}))
	s.Root.debugBar.SendStoreCall("SystemStore.PermanentDeleteByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerSystemStore) Save(system *model.System) error {
	start := time.Now()

	err := s.SystemStore.Save(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{system}))
	s.Root.debugBar.SendStoreCall("SystemStore.Save", success, elapsed)
	return err
}

func (s *DebugBarLayerSystemStore) SaveOrUpdate(system *model.System) error {
	start := time.Now()

	err := s.SystemStore.SaveOrUpdate(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{system}))
	s.Root.debugBar.SendStoreCall("SystemStore.SaveOrUpdate", success, elapsed)
	return err
}

func (s *DebugBarLayerSystemStore) SaveOrUpdateWithWarnMetricHandling(system *model.System) error {
	start := time.Now()

	err := s.SystemStore.SaveOrUpdateWithWarnMetricHandling(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{system}))
	s.Root.debugBar.SendStoreCall("SystemStore.SaveOrUpdateWithWarnMetricHandling", success, elapsed)
	return err
}

func (s *DebugBarLayerSystemStore) Update(system *model.System) error {
	start := time.Now()

	err := s.SystemStore.Update(system)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{system}))
	s.Root.debugBar.SendStoreCall("SystemStore.Update", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) AnalyticsGetTeamCountForScheme(schemeID string) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.AnalyticsGetTeamCountForScheme(schemeID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{schemeID}))
	s.Root.debugBar.SendStoreCall("TeamStore.AnalyticsGetTeamCountForScheme", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) AnalyticsTeamCount(opts *model.TeamSearch) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.AnalyticsTeamCount(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("TeamStore.AnalyticsTeamCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) ClearAllCustomRoleAssignments() error {
	start := time.Now()

	err := s.TeamStore.ClearAllCustomRoleAssignments()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.ClearAllCustomRoleAssignments", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) ClearCaches() {
	start := time.Now()

	s.TeamStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.ClearCaches", success, elapsed)

}

func (s *DebugBarLayerTeamStore) Get(id string) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("TeamStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetActiveMemberCount(teamID string, restrictions *model.ViewUsersRestrictions) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.GetActiveMemberCount(teamID, restrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, restrictions}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetActiveMemberCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetAll() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetAllForExportAfter(limit int, afterID string) ([]*model.TeamForExport, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllForExportAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit, afterID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetAllForExportAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetAllPage(offset int, limit int, opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllPage(offset, limit, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit, opts}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetAllPage", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetAllPrivateTeamListing() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllPrivateTeamListing()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetAllPrivateTeamListing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetAllTeamListing() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetAllTeamListing()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetAllTeamListing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetByEmptyInviteID() ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByEmptyInviteID()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetByEmptyInviteID", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetByInviteId(inviteID string) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByInviteId(inviteID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{inviteID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetByInviteId", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetByName(name string) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByName(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{name}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetByName", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetByNames(name []string) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetByNames(name)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{name}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetByNames", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetChannelUnreadsForAllTeams(excludeTeamID string, userID string) ([]*model.ChannelUnread, error) {
	start := time.Now()

	result, err := s.TeamStore.GetChannelUnreadsForAllTeams(excludeTeamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{excludeTeamID, userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetChannelUnreadsForAllTeams", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetChannelUnreadsForTeam(teamID string, userID string) ([]*model.ChannelUnread, error) {
	start := time.Now()

	result, err := s.TeamStore.GetChannelUnreadsForTeam(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetChannelUnreadsForTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetCommonTeamIDsForTwoUsers(userID string, otherUserID string) ([]string, error) {
	start := time.Now()

	result, err := s.TeamStore.GetCommonTeamIDsForTwoUsers(userID, otherUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, otherUserID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetCommonTeamIDsForTwoUsers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetMany(ids []string) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMany(ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ids}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetMany", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetMember(ctx context.Context, teamID string, userID string) (*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMember(ctx, teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, teamID, userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetMembers(teamID string, offset int, limit int, teamMembersGetOptions *model.TeamMembersGetOptions) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMembers(teamID, offset, limit, teamMembersGetOptions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, offset, limit, teamMembersGetOptions}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetMembersByIds(teamID string, userIds []string, restrictions *model.ViewUsersRestrictions) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetMembersByIds(teamID, userIds, restrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userIds, restrictions}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetMembersByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetNewTeamMembersSince(teamID string, since int64, offset int, limit int) (*model.NewTeamMembersList, int64, error) {
	start := time.Now()

	result, resultVar1, err := s.TeamStore.GetNewTeamMembersSince(teamID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetNewTeamMembersSince", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerTeamStore) GetTeamMembersForExport(userID string) ([]*model.TeamMemberForExport, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamMembersForExport(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetTeamMembersForExport", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetTeamsByScheme(schemeID string, offset int, limit int) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsByScheme(schemeID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{schemeID, offset, limit}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetTeamsByScheme", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetTeamsByUserId(userID string) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsByUserId(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetTeamsByUserId", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetTeamsForUser(ctx context.Context, userID string, excludeTeamID string, includeDeleted bool) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsForUser(ctx, userID, excludeTeamID, includeDeleted)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, userID, excludeTeamID, includeDeleted}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetTeamsForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetTeamsForUserWithPagination(userID string, page int, perPage int) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTeamsForUserWithPagination(userID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, page, perPage}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetTeamsForUserWithPagination", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetTotalMemberCount(teamID string, restrictions *model.ViewUsersRestrictions) (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.GetTotalMemberCount(teamID, restrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, restrictions}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetTotalMemberCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GetUserTeamIds(userID string, allowFromCache bool) ([]string, error) {
	start := time.Now()

	result, err := s.TeamStore.GetUserTeamIds(userID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, allowFromCache}))
	s.Root.debugBar.SendStoreCall("TeamStore.GetUserTeamIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) GroupSyncedTeamCount() (int64, error) {
	start := time.Now()

	result, err := s.TeamStore.GroupSyncedTeamCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.GroupSyncedTeamCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) InvalidateAllTeamIdsForUser(userID string) {
	start := time.Now()

	s.TeamStore.InvalidateAllTeamIdsForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.InvalidateAllTeamIdsForUser", success, elapsed)

}

func (s *DebugBarLayerTeamStore) MigrateTeamMembers(fromTeamID string, fromUserID string) (map[string]string, error) {
	start := time.Now()

	result, err := s.TeamStore.MigrateTeamMembers(fromTeamID, fromUserID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{fromTeamID, fromUserID}))
	s.Root.debugBar.SendStoreCall("TeamStore.MigrateTeamMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) PermanentDelete(teamID string) error {
	start := time.Now()

	err := s.TeamStore.PermanentDelete(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("TeamStore.PermanentDelete", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) RemoveAllMembersByTeam(teamID string) error {
	start := time.Now()

	err := s.TeamStore.RemoveAllMembersByTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("TeamStore.RemoveAllMembersByTeam", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) RemoveAllMembersByUser(userID string) error {
	start := time.Now()

	err := s.TeamStore.RemoveAllMembersByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.RemoveAllMembersByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) RemoveMember(teamID string, userID string) error {
	start := time.Now()

	err := s.TeamStore.RemoveMember(teamID, userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID}))
	s.Root.debugBar.SendStoreCall("TeamStore.RemoveMember", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) RemoveMembers(teamID string, userIds []string) error {
	start := time.Now()

	err := s.TeamStore.RemoveMembers(teamID, userIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userIds}))
	s.Root.debugBar.SendStoreCall("TeamStore.RemoveMembers", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) ResetAllTeamSchemes() error {
	start := time.Now()

	err := s.TeamStore.ResetAllTeamSchemes()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("TeamStore.ResetAllTeamSchemes", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) Save(team *model.Team) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.Save(team)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{team}))
	s.Root.debugBar.SendStoreCall("TeamStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) SaveMember(member *model.TeamMember, maxUsersPerTeam int) (*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.SaveMember(member, maxUsersPerTeam)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{member, maxUsersPerTeam}))
	s.Root.debugBar.SendStoreCall("TeamStore.SaveMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) SaveMultipleMembers(members []*model.TeamMember, maxUsersPerTeam int) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.SaveMultipleMembers(members, maxUsersPerTeam)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{members, maxUsersPerTeam}))
	s.Root.debugBar.SendStoreCall("TeamStore.SaveMultipleMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) SearchAll(opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.SearchAll(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("TeamStore.SearchAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) SearchAllPaged(opts *model.TeamSearch) ([]*model.Team, int64, error) {
	start := time.Now()

	result, resultVar1, err := s.TeamStore.SearchAllPaged(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("TeamStore.SearchAllPaged", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerTeamStore) SearchOpen(opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.SearchOpen(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("TeamStore.SearchOpen", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) SearchPrivate(opts *model.TeamSearch) ([]*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.SearchPrivate(opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{opts}))
	s.Root.debugBar.SendStoreCall("TeamStore.SearchPrivate", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) Update(team *model.Team) (*model.Team, error) {
	start := time.Now()

	result, err := s.TeamStore.Update(team)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{team}))
	s.Root.debugBar.SendStoreCall("TeamStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) UpdateLastTeamIconUpdate(teamID string, curTime int64) error {
	start := time.Now()

	err := s.TeamStore.UpdateLastTeamIconUpdate(teamID, curTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, curTime}))
	s.Root.debugBar.SendStoreCall("TeamStore.UpdateLastTeamIconUpdate", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) UpdateMember(member *model.TeamMember) (*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.UpdateMember(member)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{member}))
	s.Root.debugBar.SendStoreCall("TeamStore.UpdateMember", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) UpdateMembersRole(teamID string, userIDs []string) error {
	start := time.Now()

	err := s.TeamStore.UpdateMembersRole(teamID, userIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userIDs}))
	s.Root.debugBar.SendStoreCall("TeamStore.UpdateMembersRole", success, elapsed)
	return err
}

func (s *DebugBarLayerTeamStore) UpdateMultipleMembers(members []*model.TeamMember) ([]*model.TeamMember, error) {
	start := time.Now()

	result, err := s.TeamStore.UpdateMultipleMembers(members)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{members}))
	s.Root.debugBar.SendStoreCall("TeamStore.UpdateMultipleMembers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTeamStore) UserBelongsToTeams(userID string, teamIds []string) (bool, error) {
	start := time.Now()

	result, err := s.TeamStore.UserBelongsToTeams(userID, teamIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamIds}))
	s.Root.debugBar.SendStoreCall("TeamStore.UserBelongsToTeams", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTermsOfServiceStore) Get(id string, allowFromCache bool) (*model.TermsOfService, error) {
	start := time.Now()

	result, err := s.TermsOfServiceStore.Get(id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, allowFromCache}))
	s.Root.debugBar.SendStoreCall("TermsOfServiceStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTermsOfServiceStore) GetLatest(allowFromCache bool) (*model.TermsOfService, error) {
	start := time.Now()

	result, err := s.TermsOfServiceStore.GetLatest(allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{allowFromCache}))
	s.Root.debugBar.SendStoreCall("TermsOfServiceStore.GetLatest", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTermsOfServiceStore) Save(termsOfService *model.TermsOfService) (*model.TermsOfService, error) {
	start := time.Now()

	result, err := s.TermsOfServiceStore.Save(termsOfService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{termsOfService}))
	s.Root.debugBar.SendStoreCall("TermsOfServiceStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) DeleteMembershipForUser(userId string, postID string) error {
	start := time.Now()

	err := s.ThreadStore.DeleteMembershipForUser(userId, postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, postID}))
	s.Root.debugBar.SendStoreCall("ThreadStore.DeleteMembershipForUser", success, elapsed)
	return err
}

func (s *DebugBarLayerThreadStore) DeleteOrphanedRows(limit int) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.DeleteOrphanedRows(limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit}))
	s.Root.debugBar.SendStoreCall("ThreadStore.DeleteOrphanedRows", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) Get(id string) (*model.Thread, error) {
	start := time.Now()

	result, err := s.ThreadStore.Get(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("ThreadStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetMembershipForUser(userId string, postID string) (*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetMembershipForUser(userId, postID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, postID}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetMembershipForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetMembershipsForUser(userId string, teamID string) ([]*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetMembershipsForUser(userId, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, teamID}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetMembershipsForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetTeamsUnreadForUser(userID string, teamIDs []string, includeUrgentMentionCount bool) (map[string]*model.TeamUnread, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTeamsUnreadForUser(userID, teamIDs, includeUrgentMentionCount)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamIDs, includeUrgentMentionCount}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetTeamsUnreadForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetThreadFollowers(threadID string, fetchOnlyActive bool) ([]string, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadFollowers(threadID, fetchOnlyActive)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{threadID, fetchOnlyActive}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetThreadFollowers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetThreadForUser(threadMembership *model.ThreadMembership, extended bool, postPriorityIsEnabled bool) (*model.ThreadResponse, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadForUser(threadMembership, extended, postPriorityIsEnabled)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{threadMembership, extended, postPriorityIsEnabled}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetThreadForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetThreadUnreadReplyCount(threadMembership *model.ThreadMembership) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadUnreadReplyCount(threadMembership)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{threadMembership}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetThreadUnreadReplyCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetThreadsForUser(userId string, teamID string, opts model.GetUserThreadsOpts) ([]*model.ThreadResponse, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetThreadsForUser(userId, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, teamID, opts}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetThreadsForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetTopThreadsForTeamSince(teamID string, userID string, since int64, offset int, limit int) (*model.TopThreadList, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTopThreadsForTeamSince(teamID, userID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetTopThreadsForTeamSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetTopThreadsForUserSince(teamID string, userID string, since int64, offset int, limit int) (*model.TopThreadList, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTopThreadsForUserSince(teamID, userID, since, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, since, offset, limit}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetTopThreadsForUserSince", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetTotalThreads(userId string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalThreads(userId, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, teamID, opts}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetTotalThreads", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetTotalUnreadMentions(userId string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalUnreadMentions(userId, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, teamID, opts}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetTotalUnreadMentions", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetTotalUnreadThreads(userId string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalUnreadThreads(userId, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, teamID, opts}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetTotalUnreadThreads", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) GetTotalUnreadUrgentMentions(userId string, teamID string, opts model.GetUserThreadsOpts) (int64, error) {
	start := time.Now()

	result, err := s.ThreadStore.GetTotalUnreadUrgentMentions(userId, teamID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userId, teamID, opts}))
	s.Root.debugBar.SendStoreCall("ThreadStore.GetTotalUnreadUrgentMentions", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) MaintainMembership(userID string, postID string, opts store.ThreadMembershipOpts) (*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.MaintainMembership(userID, postID, opts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, postID, opts}))
	s.Root.debugBar.SendStoreCall("ThreadStore.MaintainMembership", success, elapsed)
	return result, err
}

func (s *DebugBarLayerThreadStore) MarkAllAsRead(userID string, threadIds []string) error {
	start := time.Now()

	err := s.ThreadStore.MarkAllAsRead(userID, threadIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, threadIds}))
	s.Root.debugBar.SendStoreCall("ThreadStore.MarkAllAsRead", success, elapsed)
	return err
}

func (s *DebugBarLayerThreadStore) MarkAllAsReadByChannels(userID string, channelIDs []string) error {
	start := time.Now()

	err := s.ThreadStore.MarkAllAsReadByChannels(userID, channelIDs)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelIDs}))
	s.Root.debugBar.SendStoreCall("ThreadStore.MarkAllAsReadByChannels", success, elapsed)
	return err
}

func (s *DebugBarLayerThreadStore) MarkAllAsReadByTeam(userID string, teamID string) error {
	start := time.Now()

	err := s.ThreadStore.MarkAllAsReadByTeam(userID, teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, teamID}))
	s.Root.debugBar.SendStoreCall("ThreadStore.MarkAllAsReadByTeam", success, elapsed)
	return err
}

func (s *DebugBarLayerThreadStore) MarkAsRead(userID string, threadID string, timestamp int64) error {
	start := time.Now()

	err := s.ThreadStore.MarkAsRead(userID, threadID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, threadID, timestamp}))
	s.Root.debugBar.SendStoreCall("ThreadStore.MarkAsRead", success, elapsed)
	return err
}

func (s *DebugBarLayerThreadStore) PermanentDeleteBatchForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ThreadStore.PermanentDeleteBatchForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{now, globalPolicyEndTime, limit, cursor}))
	s.Root.debugBar.SendStoreCall("ThreadStore.PermanentDeleteBatchForRetentionPolicies", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerThreadStore) PermanentDeleteBatchThreadMembershipsForRetentionPolicies(now int64, globalPolicyEndTime int64, limit int64, cursor model.RetentionPolicyCursor) (int64, model.RetentionPolicyCursor, error) {
	start := time.Now()

	result, resultVar1, err := s.ThreadStore.PermanentDeleteBatchThreadMembershipsForRetentionPolicies(now, globalPolicyEndTime, limit, cursor)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{now, globalPolicyEndTime, limit, cursor}))
	s.Root.debugBar.SendStoreCall("ThreadStore.PermanentDeleteBatchThreadMembershipsForRetentionPolicies", success, elapsed)
	return result, resultVar1, err
}

func (s *DebugBarLayerThreadStore) UpdateMembership(membership *model.ThreadMembership) (*model.ThreadMembership, error) {
	start := time.Now()

	result, err := s.ThreadStore.UpdateMembership(membership)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{membership}))
	s.Root.debugBar.SendStoreCall("ThreadStore.UpdateMembership", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTokenStore) Cleanup(expiryTime int64) {
	start := time.Now()

	s.TokenStore.Cleanup(expiryTime)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{expiryTime}))
	s.Root.debugBar.SendStoreCall("TokenStore.Cleanup", success, elapsed)

}

func (s *DebugBarLayerTokenStore) Delete(token string) error {
	start := time.Now()

	err := s.TokenStore.Delete(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{token}))
	s.Root.debugBar.SendStoreCall("TokenStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerTokenStore) GetAllTokensByType(tokenType string) ([]*model.Token, error) {
	start := time.Now()

	result, err := s.TokenStore.GetAllTokensByType(tokenType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{tokenType}))
	s.Root.debugBar.SendStoreCall("TokenStore.GetAllTokensByType", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTokenStore) GetByToken(token string) (*model.Token, error) {
	start := time.Now()

	result, err := s.TokenStore.GetByToken(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{token}))
	s.Root.debugBar.SendStoreCall("TokenStore.GetByToken", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTokenStore) RemoveAllTokensByType(tokenType string) error {
	start := time.Now()

	err := s.TokenStore.RemoveAllTokensByType(tokenType)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{tokenType}))
	s.Root.debugBar.SendStoreCall("TokenStore.RemoveAllTokensByType", success, elapsed)
	return err
}

func (s *DebugBarLayerTokenStore) Save(recovery *model.Token) error {
	start := time.Now()

	err := s.TokenStore.Save(recovery)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{recovery}))
	s.Root.debugBar.SendStoreCall("TokenStore.Save", success, elapsed)
	return err
}

func (s *DebugBarLayerTrueUpReviewStore) CreateTrueUpReviewStatusRecord(reviewStatus *model.TrueUpReviewStatus) (*model.TrueUpReviewStatus, error) {
	start := time.Now()

	result, err := s.TrueUpReviewStore.CreateTrueUpReviewStatusRecord(reviewStatus)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{reviewStatus}))
	s.Root.debugBar.SendStoreCall("TrueUpReviewStore.CreateTrueUpReviewStatusRecord", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTrueUpReviewStore) GetTrueUpReviewStatus(dueDate int64) (*model.TrueUpReviewStatus, error) {
	start := time.Now()

	result, err := s.TrueUpReviewStore.GetTrueUpReviewStatus(dueDate)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{dueDate}))
	s.Root.debugBar.SendStoreCall("TrueUpReviewStore.GetTrueUpReviewStatus", success, elapsed)
	return result, err
}

func (s *DebugBarLayerTrueUpReviewStore) Update(reviewStatus *model.TrueUpReviewStatus) (*model.TrueUpReviewStatus, error) {
	start := time.Now()

	result, err := s.TrueUpReviewStore.Update(reviewStatus)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{reviewStatus}))
	s.Root.debugBar.SendStoreCall("TrueUpReviewStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUploadSessionStore) Delete(id string) error {
	start := time.Now()

	err := s.UploadSessionStore.Delete(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("UploadSessionStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerUploadSessionStore) Get(ctx context.Context, id string) (*model.UploadSession, error) {
	start := time.Now()

	result, err := s.UploadSessionStore.Get(ctx, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, id}))
	s.Root.debugBar.SendStoreCall("UploadSessionStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUploadSessionStore) GetForUser(userID string) ([]*model.UploadSession, error) {
	start := time.Now()

	result, err := s.UploadSessionStore.GetForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UploadSessionStore.GetForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUploadSessionStore) Save(session *model.UploadSession) (*model.UploadSession, error) {
	start := time.Now()

	result, err := s.UploadSessionStore.Save(session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{session}))
	s.Root.debugBar.SendStoreCall("UploadSessionStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUploadSessionStore) Update(session *model.UploadSession) error {
	start := time.Now()

	err := s.UploadSessionStore.Update(session)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{session}))
	s.Root.debugBar.SendStoreCall("UploadSessionStore.Update", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) AnalyticsActiveCount(timestamp int64, options model.UserCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsActiveCount(timestamp, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{timestamp, options}))
	s.Root.debugBar.SendStoreCall("UserStore.AnalyticsActiveCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) AnalyticsActiveCountForPeriod(startTime int64, endTime int64, options model.UserCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsActiveCountForPeriod(startTime, endTime, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{startTime, endTime, options}))
	s.Root.debugBar.SendStoreCall("UserStore.AnalyticsActiveCountForPeriod", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) AnalyticsGetExternalUsers(hostDomain string) (bool, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetExternalUsers(hostDomain)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{hostDomain}))
	s.Root.debugBar.SendStoreCall("UserStore.AnalyticsGetExternalUsers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) AnalyticsGetGuestCount() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetGuestCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.AnalyticsGetGuestCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) AnalyticsGetInactiveUsersCount() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetInactiveUsersCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.AnalyticsGetInactiveUsersCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) AnalyticsGetSystemAdminCount() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.AnalyticsGetSystemAdminCount()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.AnalyticsGetSystemAdminCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) AutocompleteUsersInChannel(teamID string, channelID string, term string, options *model.UserSearchOptions) (*model.UserAutocompleteInChannel, error) {
	start := time.Now()

	result, err := s.UserStore.AutocompleteUsersInChannel(teamID, channelID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, channelID, term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.AutocompleteUsersInChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) ClearAllCustomRoleAssignments() error {
	start := time.Now()

	err := s.UserStore.ClearAllCustomRoleAssignments()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.ClearAllCustomRoleAssignments", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) ClearCaches() {
	start := time.Now()

	s.UserStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.ClearCaches", success, elapsed)

}

func (s *DebugBarLayerUserStore) Count(options model.UserCountOptions) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.Count(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("UserStore.Count", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) DeactivateGuests() ([]string, error) {
	start := time.Now()

	result, err := s.UserStore.DeactivateGuests()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.DeactivateGuests", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) DemoteUserToGuest(userID string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.DemoteUserToGuest(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.DemoteUserToGuest", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) Get(ctx context.Context, id string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.Get(ctx, id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, id}))
	s.Root.debugBar.SendStoreCall("UserStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetAll() ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAll()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetAllAfter(limit int, afterID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllAfter(limit, afterID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{limit, afterID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetAllAfter", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetAllNotInAuthService(authServices []string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllNotInAuthService(authServices)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{authServices}))
	s.Root.debugBar.SendStoreCall("UserStore.GetAllNotInAuthService", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetAllProfiles(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllProfiles(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("UserStore.GetAllProfiles", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetAllProfilesInChannel(ctx context.Context, channelID string, allowFromCache bool) (map[string]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllProfilesInChannel(ctx, channelID, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, channelID, allowFromCache}))
	s.Root.debugBar.SendStoreCall("UserStore.GetAllProfilesInChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetAllUsingAuthService(authService string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetAllUsingAuthService(authService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{authService}))
	s.Root.debugBar.SendStoreCall("UserStore.GetAllUsingAuthService", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetAnyUnreadPostCountForChannel(userID string, channelID string) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.GetAnyUnreadPostCountForChannel(userID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetAnyUnreadPostCountForChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetByAuth(authData *string, authService string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetByAuth(authData, authService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{authData, authService}))
	s.Root.debugBar.SendStoreCall("UserStore.GetByAuth", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetByEmail(email string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetByEmail(email)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{email}))
	s.Root.debugBar.SendStoreCall("UserStore.GetByEmail", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetByUsername(username string) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetByUsername(username)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{username}))
	s.Root.debugBar.SendStoreCall("UserStore.GetByUsername", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetChannelGroupUsers(channelID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetChannelGroupUsers(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetChannelGroupUsers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetEtagForAllProfiles() string {
	start := time.Now()

	result := s.UserStore.GetEtagForAllProfiles()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.GetEtagForAllProfiles", success, elapsed)
	return result
}

func (s *DebugBarLayerUserStore) GetEtagForProfiles(teamID string) string {
	start := time.Now()

	result := s.UserStore.GetEtagForProfiles(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetEtagForProfiles", success, elapsed)
	return result
}

func (s *DebugBarLayerUserStore) GetEtagForProfilesNotInTeam(teamID string) string {
	start := time.Now()

	result := s.UserStore.GetEtagForProfilesNotInTeam(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetEtagForProfilesNotInTeam", success, elapsed)
	return result
}

func (s *DebugBarLayerUserStore) GetFirstSystemAdminID() (string, error) {
	start := time.Now()

	result, err := s.UserStore.GetFirstSystemAdminID()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.GetFirstSystemAdminID", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetForLogin(loginID string, allowSignInWithUsername bool, allowSignInWithEmail bool) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetForLogin(loginID, allowSignInWithUsername, allowSignInWithEmail)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{loginID, allowSignInWithUsername, allowSignInWithEmail}))
	s.Root.debugBar.SendStoreCall("UserStore.GetForLogin", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetKnownUsers(userID string) ([]string, error) {
	start := time.Now()

	result, err := s.UserStore.GetKnownUsers(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetKnownUsers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetMany(ctx context.Context, ids []string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetMany(ctx, ids)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, ids}))
	s.Root.debugBar.SendStoreCall("UserStore.GetMany", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetNewUsersForTeam(teamID string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetNewUsersForTeam(teamID, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, offset, limit, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("UserStore.GetNewUsersForTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfileByGroupChannelIdsForUser(userID string, channelIds []string) (map[string][]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfileByGroupChannelIdsForUser(userID, channelIds)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelIds}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfileByGroupChannelIdsForUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfileByIds(ctx context.Context, userIds []string, options *store.UserGetByIdsOpts, allowFromCache bool) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfileByIds(ctx, userIds, options, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{ctx, userIds, options, allowFromCache}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfileByIds", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfiles(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfiles(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfiles", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfilesByUsernames(usernames []string, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesByUsernames(usernames, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{usernames, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfilesByUsernames", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfilesInChannel(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesInChannel(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfilesInChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfilesInChannelByAdmin(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesInChannelByAdmin(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfilesInChannelByAdmin", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfilesInChannelByStatus(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesInChannelByStatus(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfilesInChannelByStatus", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfilesNotInChannel(teamID string, channelId string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesNotInChannel(teamID, channelId, groupConstrained, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, channelId, groupConstrained, offset, limit, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfilesNotInChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfilesNotInTeam(teamID string, groupConstrained bool, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesNotInTeam(teamID, groupConstrained, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, groupConstrained, offset, limit, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfilesNotInTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetProfilesWithoutTeam(options *model.UserGetOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetProfilesWithoutTeam(options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{options}))
	s.Root.debugBar.SendStoreCall("UserStore.GetProfilesWithoutTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetRecentlyActiveUsersForTeam(teamID string, offset int, limit int, viewRestrictions *model.ViewUsersRestrictions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetRecentlyActiveUsersForTeam(teamID, offset, limit, viewRestrictions)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, offset, limit, viewRestrictions}))
	s.Root.debugBar.SendStoreCall("UserStore.GetRecentlyActiveUsersForTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetSystemAdminProfiles() (map[string]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetSystemAdminProfiles()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.GetSystemAdminProfiles", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetTeamGroupUsers(teamID string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetTeamGroupUsers(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetTeamGroupUsers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetUnreadCount(userID string, isCRTEnabled bool) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.GetUnreadCount(userID, isCRTEnabled)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, isCRTEnabled}))
	s.Root.debugBar.SendStoreCall("UserStore.GetUnreadCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetUnreadCountForChannel(userID string, channelID string) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.GetUnreadCountForChannel(userID, channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, channelID}))
	s.Root.debugBar.SendStoreCall("UserStore.GetUnreadCountForChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetUsersBatchForIndexing(startTime int64, startFileID string, limit int) ([]*model.UserForIndexing, error) {
	start := time.Now()

	result, err := s.UserStore.GetUsersBatchForIndexing(startTime, startFileID, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{startTime, startFileID, limit}))
	s.Root.debugBar.SendStoreCall("UserStore.GetUsersBatchForIndexing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) GetUsersWithInvalidEmails(page int, perPage int, restrictedDomains string) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.GetUsersWithInvalidEmails(page, perPage, restrictedDomains)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{page, perPage, restrictedDomains}))
	s.Root.debugBar.SendStoreCall("UserStore.GetUsersWithInvalidEmails", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) InferSystemInstallDate() (int64, error) {
	start := time.Now()

	result, err := s.UserStore.InferSystemInstallDate()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("UserStore.InferSystemInstallDate", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) InsertUsers(users []*model.User) error {
	start := time.Now()

	err := s.UserStore.InsertUsers(users)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{users}))
	s.Root.debugBar.SendStoreCall("UserStore.InsertUsers", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) InvalidateProfileCacheForUser(userID string) {
	start := time.Now()

	s.UserStore.InvalidateProfileCacheForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.InvalidateProfileCacheForUser", success, elapsed)

}

func (s *DebugBarLayerUserStore) InvalidateProfilesInChannelCache(channelID string) {
	start := time.Now()

	s.UserStore.InvalidateProfilesInChannelCache(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("UserStore.InvalidateProfilesInChannelCache", success, elapsed)

}

func (s *DebugBarLayerUserStore) InvalidateProfilesInChannelCacheByUser(userID string) {
	start := time.Now()

	s.UserStore.InvalidateProfilesInChannelCacheByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.InvalidateProfilesInChannelCacheByUser", success, elapsed)

}

func (s *DebugBarLayerUserStore) IsEmpty(excludeBots bool) (bool, error) {
	start := time.Now()

	result, err := s.UserStore.IsEmpty(excludeBots)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{excludeBots}))
	s.Root.debugBar.SendStoreCall("UserStore.IsEmpty", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) PermanentDelete(userID string) error {
	start := time.Now()

	err := s.UserStore.PermanentDelete(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.PermanentDelete", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) PromoteGuestToUser(userID string) error {
	start := time.Now()

	err := s.UserStore.PromoteGuestToUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.PromoteGuestToUser", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) ResetAuthDataToEmailForUsers(service string, userIDs []string, includeDeleted bool, dryRun bool) (int, error) {
	start := time.Now()

	result, err := s.UserStore.ResetAuthDataToEmailForUsers(service, userIDs, includeDeleted, dryRun)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{service, userIDs, includeDeleted, dryRun}))
	s.Root.debugBar.SendStoreCall("UserStore.ResetAuthDataToEmailForUsers", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) ResetLastPictureUpdate(userID string) error {
	start := time.Now()

	err := s.UserStore.ResetLastPictureUpdate(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.ResetLastPictureUpdate", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) Save(user *model.User) (*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.Save(user)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{user}))
	s.Root.debugBar.SendStoreCall("UserStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) Search(teamID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.Search(teamID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.Search", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) SearchInChannel(channelID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchInChannel(channelID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.SearchInChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) SearchInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchInGroup(groupID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.SearchInGroup", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) SearchNotInChannel(teamID string, channelID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchNotInChannel(teamID, channelID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, channelID, term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.SearchNotInChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) SearchNotInGroup(groupID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchNotInGroup(groupID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{groupID, term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.SearchNotInGroup", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) SearchNotInTeam(notInTeamID string, term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchNotInTeam(notInTeamID, term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{notInTeamID, term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.SearchNotInTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) SearchWithoutTeam(term string, options *model.UserSearchOptions) ([]*model.User, error) {
	start := time.Now()

	result, err := s.UserStore.SearchWithoutTeam(term, options)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{term, options}))
	s.Root.debugBar.SendStoreCall("UserStore.SearchWithoutTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) Update(user *model.User, allowRoleUpdate bool) (*model.UserUpdate, error) {
	start := time.Now()

	result, err := s.UserStore.Update(user, allowRoleUpdate)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{user, allowRoleUpdate}))
	s.Root.debugBar.SendStoreCall("UserStore.Update", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) UpdateAuthData(userID string, service string, authData *string, email string, resetMfa bool) (string, error) {
	start := time.Now()

	result, err := s.UserStore.UpdateAuthData(userID, service, authData, email, resetMfa)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, service, authData, email, resetMfa}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdateAuthData", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) UpdateFailedPasswordAttempts(userID string, attempts int) error {
	start := time.Now()

	err := s.UserStore.UpdateFailedPasswordAttempts(userID, attempts)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, attempts}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdateFailedPasswordAttempts", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) UpdateLastPictureUpdate(userID string) error {
	start := time.Now()

	err := s.UserStore.UpdateLastPictureUpdate(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdateLastPictureUpdate", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) UpdateMfaActive(userID string, active bool) error {
	start := time.Now()

	err := s.UserStore.UpdateMfaActive(userID, active)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, active}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdateMfaActive", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) UpdateMfaSecret(userID string, secret string) error {
	start := time.Now()

	err := s.UserStore.UpdateMfaSecret(userID, secret)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, secret}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdateMfaSecret", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) UpdateNotifyProps(userID string, props map[string]string) error {
	start := time.Now()

	err := s.UserStore.UpdateNotifyProps(userID, props)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, props}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdateNotifyProps", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) UpdatePassword(userID string, newPassword string) error {
	start := time.Now()

	err := s.UserStore.UpdatePassword(userID, newPassword)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, newPassword}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdatePassword", success, elapsed)
	return err
}

func (s *DebugBarLayerUserStore) UpdateUpdateAt(userID string) (int64, error) {
	start := time.Now()

	result, err := s.UserStore.UpdateUpdateAt(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserStore.UpdateUpdateAt", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserStore) VerifyEmail(userID string, email string) (string, error) {
	start := time.Now()

	result, err := s.UserStore.VerifyEmail(userID, email)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, email}))
	s.Root.debugBar.SendStoreCall("UserStore.VerifyEmail", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserAccessTokenStore) Delete(tokenID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.Delete(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{tokenID}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerUserAccessTokenStore) DeleteAllForUser(userID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.DeleteAllForUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.DeleteAllForUser", success, elapsed)
	return err
}

func (s *DebugBarLayerUserAccessTokenStore) Get(tokenID string) (*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.Get(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{tokenID}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.Get", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserAccessTokenStore) GetAll(offset int, limit int) ([]*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.GetAll(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.GetAll", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserAccessTokenStore) GetByToken(tokenString string) (*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.GetByToken(tokenString)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{tokenString}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.GetByToken", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserAccessTokenStore) GetByUser(userID string, page int, perPage int) ([]*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.GetByUser(userID, page, perPage)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, page, perPage}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.GetByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserAccessTokenStore) Save(token *model.UserAccessToken) (*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.Save(token)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{token}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserAccessTokenStore) Search(term string) ([]*model.UserAccessToken, error) {
	start := time.Now()

	result, err := s.UserAccessTokenStore.Search(term)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{term}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.Search", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserAccessTokenStore) UpdateTokenDisable(tokenID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.UpdateTokenDisable(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{tokenID}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.UpdateTokenDisable", success, elapsed)
	return err
}

func (s *DebugBarLayerUserAccessTokenStore) UpdateTokenEnable(tokenID string) error {
	start := time.Now()

	err := s.UserAccessTokenStore.UpdateTokenEnable(tokenID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{tokenID}))
	s.Root.debugBar.SendStoreCall("UserAccessTokenStore.UpdateTokenEnable", success, elapsed)
	return err
}

func (s *DebugBarLayerUserTermsOfServiceStore) Delete(userID string, termsOfServiceId string) error {
	start := time.Now()

	err := s.UserTermsOfServiceStore.Delete(userID, termsOfServiceId)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, termsOfServiceId}))
	s.Root.debugBar.SendStoreCall("UserTermsOfServiceStore.Delete", success, elapsed)
	return err
}

func (s *DebugBarLayerUserTermsOfServiceStore) GetByUser(userID string) (*model.UserTermsOfService, error) {
	start := time.Now()

	result, err := s.UserTermsOfServiceStore.GetByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("UserTermsOfServiceStore.GetByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerUserTermsOfServiceStore) Save(userTermsOfService *model.UserTermsOfService) (*model.UserTermsOfService, error) {
	start := time.Now()

	result, err := s.UserTermsOfServiceStore.Save(userTermsOfService)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userTermsOfService}))
	s.Root.debugBar.SendStoreCall("UserTermsOfServiceStore.Save", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) AnalyticsIncomingCount(teamID string) (int64, error) {
	start := time.Now()

	result, err := s.WebhookStore.AnalyticsIncomingCount(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("WebhookStore.AnalyticsIncomingCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) AnalyticsOutgoingCount(teamID string) (int64, error) {
	start := time.Now()

	result, err := s.WebhookStore.AnalyticsOutgoingCount(teamID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID}))
	s.Root.debugBar.SendStoreCall("WebhookStore.AnalyticsOutgoingCount", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) ClearCaches() {
	start := time.Now()

	s.WebhookStore.ClearCaches()

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{}))
	s.Root.debugBar.SendStoreCall("WebhookStore.ClearCaches", success, elapsed)

}

func (s *DebugBarLayerWebhookStore) DeleteIncoming(webhookID string, timestamp int64) error {
	start := time.Now()

	err := s.WebhookStore.DeleteIncoming(webhookID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhookID, timestamp}))
	s.Root.debugBar.SendStoreCall("WebhookStore.DeleteIncoming", success, elapsed)
	return err
}

func (s *DebugBarLayerWebhookStore) DeleteOutgoing(webhookID string, timestamp int64) error {
	start := time.Now()

	err := s.WebhookStore.DeleteOutgoing(webhookID, timestamp)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhookID, timestamp}))
	s.Root.debugBar.SendStoreCall("WebhookStore.DeleteOutgoing", success, elapsed)
	return err
}

func (s *DebugBarLayerWebhookStore) GetIncoming(id string, allowFromCache bool) (*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncoming(id, allowFromCache)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id, allowFromCache}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetIncoming", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetIncomingByChannel(channelID string) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetIncomingByChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetIncomingByTeam(teamID string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingByTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetIncomingByTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetIncomingByTeamByUser(teamID string, userID string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingByTeamByUser(teamID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetIncomingByTeamByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetIncomingList(offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingList(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetIncomingList", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetIncomingListByUser(userID string, offset int, limit int) ([]*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetIncomingListByUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetIncomingListByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetOutgoing(id string) (*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoing(id)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{id}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetOutgoing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetOutgoingByChannel(channelID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByChannel(channelID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetOutgoingByChannel", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetOutgoingByChannelByUser(channelID string, userID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByChannelByUser(channelID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID, userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetOutgoingByChannelByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetOutgoingByTeam(teamID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByTeam(teamID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetOutgoingByTeam", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetOutgoingByTeamByUser(teamID string, userID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingByTeamByUser(teamID, userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{teamID, userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetOutgoingByTeamByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetOutgoingList(offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingList(offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetOutgoingList", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) GetOutgoingListByUser(userID string, offset int, limit int) ([]*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.GetOutgoingListByUser(userID, offset, limit)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID, offset, limit}))
	s.Root.debugBar.SendStoreCall("WebhookStore.GetOutgoingListByUser", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) InvalidateWebhookCache(webhook string) {
	start := time.Now()

	s.WebhookStore.InvalidateWebhookCache(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if true {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhook}))
	s.Root.debugBar.SendStoreCall("WebhookStore.InvalidateWebhookCache", success, elapsed)

}

func (s *DebugBarLayerWebhookStore) PermanentDeleteIncomingByChannel(channelID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteIncomingByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("WebhookStore.PermanentDeleteIncomingByChannel", success, elapsed)
	return err
}

func (s *DebugBarLayerWebhookStore) PermanentDeleteIncomingByUser(userID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteIncomingByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("WebhookStore.PermanentDeleteIncomingByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerWebhookStore) PermanentDeleteOutgoingByChannel(channelID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteOutgoingByChannel(channelID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{channelID}))
	s.Root.debugBar.SendStoreCall("WebhookStore.PermanentDeleteOutgoingByChannel", success, elapsed)
	return err
}

func (s *DebugBarLayerWebhookStore) PermanentDeleteOutgoingByUser(userID string) error {
	start := time.Now()

	err := s.WebhookStore.PermanentDeleteOutgoingByUser(userID)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{userID}))
	s.Root.debugBar.SendStoreCall("WebhookStore.PermanentDeleteOutgoingByUser", success, elapsed)
	return err
}

func (s *DebugBarLayerWebhookStore) SaveIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.SaveIncoming(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhook}))
	s.Root.debugBar.SendStoreCall("WebhookStore.SaveIncoming", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) SaveOutgoing(webhook *model.OutgoingWebhook) (*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.SaveOutgoing(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhook}))
	s.Root.debugBar.SendStoreCall("WebhookStore.SaveOutgoing", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) UpdateIncoming(webhook *model.IncomingWebhook) (*model.IncomingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.UpdateIncoming(webhook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{webhook}))
	s.Root.debugBar.SendStoreCall("WebhookStore.UpdateIncoming", success, elapsed)
	return result, err
}

func (s *DebugBarLayerWebhookStore) UpdateOutgoing(hook *model.OutgoingWebhook) (*model.OutgoingWebhook, error) {
	start := time.Now()

	result, err := s.WebhookStore.UpdateOutgoing(hook)

	elapsed := float64(time.Since(start)) / float64(time.Second)
	success := false
	if err == nil {
		success = true
	}

	// TODO: Add the parameters information: maybe something like fmt.Sprintf("%v", []any{hook}))
	s.Root.debugBar.SendStoreCall("WebhookStore.UpdateOutgoing", success, elapsed)
	return result, err
}

func (s *DebugBarLayer) Close() {
	s.Store.Close()
}

func (s *DebugBarLayer) DropAllTables() {
	s.Store.DropAllTables()
}

func (s *DebugBarLayer) LockToMaster() {
	s.Store.LockToMaster()
}

func (s *DebugBarLayer) MarkSystemRanUnitTests() {
	s.Store.MarkSystemRanUnitTests()
}

func (s *DebugBarLayer) SetContext(context context.Context) {
	s.Store.SetContext(context)
}

func (s *DebugBarLayer) TotalMasterDbConnections() int {
	return s.Store.TotalMasterDbConnections()
}

func (s *DebugBarLayer) TotalReadDbConnections() int {
	return s.Store.TotalReadDbConnections()
}

func (s *DebugBarLayer) TotalSearchDbConnections() int {
	return s.Store.TotalSearchDbConnections()
}

func (s *DebugBarLayer) UnlockFromMaster() {
	s.Store.UnlockFromMaster()
}

func New(childStore store.Store, debugBar *debugbar.DebugBar) *DebugBarLayer {
	newStore := DebugBarLayer{
		Store:    childStore,
		debugBar: debugBar,
	}

	newStore.AuditStore = &DebugBarLayerAuditStore{AuditStore: childStore.Audit(), Root: &newStore}
	newStore.BotStore = &DebugBarLayerBotStore{BotStore: childStore.Bot(), Root: &newStore}
	newStore.ChannelStore = &DebugBarLayerChannelStore{ChannelStore: childStore.Channel(), Root: &newStore}
	newStore.ChannelMemberHistoryStore = &DebugBarLayerChannelMemberHistoryStore{ChannelMemberHistoryStore: childStore.ChannelMemberHistory(), Root: &newStore}
	newStore.ClusterDiscoveryStore = &DebugBarLayerClusterDiscoveryStore{ClusterDiscoveryStore: childStore.ClusterDiscovery(), Root: &newStore}
	newStore.CommandStore = &DebugBarLayerCommandStore{CommandStore: childStore.Command(), Root: &newStore}
	newStore.CommandWebhookStore = &DebugBarLayerCommandWebhookStore{CommandWebhookStore: childStore.CommandWebhook(), Root: &newStore}
	newStore.ComplianceStore = &DebugBarLayerComplianceStore{ComplianceStore: childStore.Compliance(), Root: &newStore}
	newStore.DraftStore = &DebugBarLayerDraftStore{DraftStore: childStore.Draft(), Root: &newStore}
	newStore.EmojiStore = &DebugBarLayerEmojiStore{EmojiStore: childStore.Emoji(), Root: &newStore}
	newStore.FileInfoStore = &DebugBarLayerFileInfoStore{FileInfoStore: childStore.FileInfo(), Root: &newStore}
	newStore.GroupStore = &DebugBarLayerGroupStore{GroupStore: childStore.Group(), Root: &newStore}
	newStore.JobStore = &DebugBarLayerJobStore{JobStore: childStore.Job(), Root: &newStore}
	newStore.LicenseStore = &DebugBarLayerLicenseStore{LicenseStore: childStore.License(), Root: &newStore}
	newStore.LinkMetadataStore = &DebugBarLayerLinkMetadataStore{LinkMetadataStore: childStore.LinkMetadata(), Root: &newStore}
	newStore.NotifyAdminStore = &DebugBarLayerNotifyAdminStore{NotifyAdminStore: childStore.NotifyAdmin(), Root: &newStore}
	newStore.OAuthStore = &DebugBarLayerOAuthStore{OAuthStore: childStore.OAuth(), Root: &newStore}
	newStore.PluginStore = &DebugBarLayerPluginStore{PluginStore: childStore.Plugin(), Root: &newStore}
	newStore.PostStore = &DebugBarLayerPostStore{PostStore: childStore.Post(), Root: &newStore}
	newStore.PostAcknowledgementStore = &DebugBarLayerPostAcknowledgementStore{PostAcknowledgementStore: childStore.PostAcknowledgement(), Root: &newStore}
	newStore.PostPriorityStore = &DebugBarLayerPostPriorityStore{PostPriorityStore: childStore.PostPriority(), Root: &newStore}
	newStore.PreferenceStore = &DebugBarLayerPreferenceStore{PreferenceStore: childStore.Preference(), Root: &newStore}
	newStore.ProductNoticesStore = &DebugBarLayerProductNoticesStore{ProductNoticesStore: childStore.ProductNotices(), Root: &newStore}
	newStore.ReactionStore = &DebugBarLayerReactionStore{ReactionStore: childStore.Reaction(), Root: &newStore}
	newStore.RemoteClusterStore = &DebugBarLayerRemoteClusterStore{RemoteClusterStore: childStore.RemoteCluster(), Root: &newStore}
	newStore.RetentionPolicyStore = &DebugBarLayerRetentionPolicyStore{RetentionPolicyStore: childStore.RetentionPolicy(), Root: &newStore}
	newStore.RoleStore = &DebugBarLayerRoleStore{RoleStore: childStore.Role(), Root: &newStore}
	newStore.SchemeStore = &DebugBarLayerSchemeStore{SchemeStore: childStore.Scheme(), Root: &newStore}
	newStore.SessionStore = &DebugBarLayerSessionStore{SessionStore: childStore.Session(), Root: &newStore}
	newStore.SharedChannelStore = &DebugBarLayerSharedChannelStore{SharedChannelStore: childStore.SharedChannel(), Root: &newStore}
	newStore.StatusStore = &DebugBarLayerStatusStore{StatusStore: childStore.Status(), Root: &newStore}
	newStore.SystemStore = &DebugBarLayerSystemStore{SystemStore: childStore.System(), Root: &newStore}
	newStore.TeamStore = &DebugBarLayerTeamStore{TeamStore: childStore.Team(), Root: &newStore}
	newStore.TermsOfServiceStore = &DebugBarLayerTermsOfServiceStore{TermsOfServiceStore: childStore.TermsOfService(), Root: &newStore}
	newStore.ThreadStore = &DebugBarLayerThreadStore{ThreadStore: childStore.Thread(), Root: &newStore}
	newStore.TokenStore = &DebugBarLayerTokenStore{TokenStore: childStore.Token(), Root: &newStore}
	newStore.TrueUpReviewStore = &DebugBarLayerTrueUpReviewStore{TrueUpReviewStore: childStore.TrueUpReview(), Root: &newStore}
	newStore.UploadSessionStore = &DebugBarLayerUploadSessionStore{UploadSessionStore: childStore.UploadSession(), Root: &newStore}
	newStore.UserStore = &DebugBarLayerUserStore{UserStore: childStore.User(), Root: &newStore}
	newStore.UserAccessTokenStore = &DebugBarLayerUserAccessTokenStore{UserAccessTokenStore: childStore.UserAccessToken(), Root: &newStore}
	newStore.UserTermsOfServiceStore = &DebugBarLayerUserTermsOfServiceStore{UserTermsOfServiceStore: childStore.UserTermsOfService(), Root: &newStore}
	newStore.WebhookStore = &DebugBarLayerWebhookStore{WebhookStore: childStore.Webhook(), Root: &newStore}
	return &newStore
}
